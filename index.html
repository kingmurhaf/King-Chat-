<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ø±Ø§Ø³Ù„ - ØªÙˆØ§ØµÙ„ Ø¹Ø¨Ø± Ø§Ù„ØµÙˆØª</title>
    <style>
        /* ========== Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙˆØ§Ù„ØªØ¹Ø±ÙŠÙØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ========== */
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --accent-primary: #8b5cf6;
            --accent-secondary: #ec4899;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border-radius-lg: 2rem;
            --border-radius-md: 1.5rem;
            --border-radius-sm: 1rem;
            --transition: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(145deg, #0a0f1e, #1a1f30);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            color: var(--text-primary);
        }

        /* ========== ØªØµÙ…ÙŠÙ… Ø§Ù„Ù‡Ø§ØªÙ ========== */
        .phone {
            max-width: 400px;
            width: 100%;
            background: var(--bg-primary);
            border-radius: 3rem;
            padding: 1.5rem 1rem;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8), 0 0 0 2px #2d3a5e inset;
            border: 1px solid #4b5563;
        }

        /* ========== Ø§Ù„Ù‡ÙŠØ¯Ø± ========== */
        .header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .badge-container {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .badge {
            background: var(--bg-secondary);
            padding: 0.3rem 1rem;
            border-radius: 2rem;
            font-size: 0.7rem;
            border: 1px solid var(--bg-tertiary);
            color: var(--text-secondary);
        }

        /* ========== Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØªØ±Ø¯Ø¯ ========== */
        .freq-panel {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .freq-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0.8rem 0;
        }

        .freq-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .freq-value {
            background: var(--bg-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 2rem;
            font-family: monospace;
            font-size: 0.9rem;
            min-width: 5rem;
            text-align: center;
        }

        input[type=range] {
            flex: 1;
            height: 0.4rem;
            border-radius: 1rem;
            background: var(--bg-tertiary);
            -webkit-appearance: none;
            margin: 0 0.8rem;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 1.2rem;
            height: 1.2rem;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 0 10px var(--accent-primary);
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .mode-selector {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .mode-btn {
            flex: 1;
            padding: 0.6rem;
            border: none;
            border-radius: 2rem;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: white;
            box-shadow: 0 0 15px var(--accent-primary);
        }

        /* ========== Ø§Ù„ÙÙŠØ¬ÙˆØ§Ù„Ø§ÙŠØ²Ø± ========== */
        .visualizer {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .wave-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 0.3rem;
            height: 5rem;
        }

        .wave-bar {
            width: 0.6rem;
            height: 1.5rem;
            background: var(--bg-tertiary);
            border-radius: 0.5rem;
            transition: height 0.1s, background 0.2s;
        }

        .wave-bar.active {
            background: linear-gradient(to top, var(--accent-primary), var(--accent-secondary));
            box-shadow: 0 0 10px var(--accent-secondary);
        }

        .freq-indicator {
            display: flex;
            justify-content: space-between;
            margin-top: 0.8rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .db-meter {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.8rem;
            background: var(--bg-primary);
            padding: 0.5rem 0.8rem;
            border-radius: 2rem;
        }

        .db-meter .bar {
            flex: 1;
            height: 0.4rem;
            background: var(--bg-tertiary);
            border-radius: 1rem;
            overflow: hidden;
        }

        .db-meter .fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, var(--success), var(--warning), var(--error));
            transition: width 0.1s;
        }

        .db-value {
            font-family: monospace;
            font-size: 0.8rem;
            min-width: 3.5rem;
            text-align: left;
        }

        /* ========== Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© ========== */
        .status-bar {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 1rem 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .led {
            width: 0.8rem;
            height: 0.8rem;
            border-radius: 50%;
            background: var(--bg-tertiary);
            transition: var(--transition);
        }

        .led.listening {
            background: var(--success);
            box-shadow: 0 0 15px var(--success);
            animation: pulse 1.5s infinite;
        }

        .led.sending {
            background: var(--warning);
            box-shadow: 0 0 15px var(--warning);
            animation: pulse 0.8s infinite;
        }

        .led.recording {
            background: var(--error);
            box-shadow: 0 0 15px var(--error);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        /* ========== Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ========== */
        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .btn {
            padding: 1rem;
            border: none;
            border-radius: var(--border-radius-md);
            font-weight: 700;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 0 #0f172a;
        }

        .btn.primary {
            background: linear-gradient(145deg, var(--accent-primary), #a855f7);
            box-shadow: 0 4px 0 #5b1e8c;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ========== Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ========== */
        .chat-area {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 1rem;
        }

        .messages {
            background: var(--bg-primary);
            border-radius: var(--border-radius-md);
            padding: 1rem;
            height: 15rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
            scroll-behavior: smooth;
        }

        .message {
            max-width: 85%;
            padding: 0.6rem 1rem;
            border-radius: 1.5rem;
            font-size: 0.9rem;
            word-wrap: break-word;
            animation: fadeIn 0.2s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.sent {
            background: linear-gradient(145deg, var(--accent-primary), #a855f7);
            align-self: flex-end;
            color: white;
        }

        .message.received {
            background: var(--bg-tertiary);
            align-self: flex-start;
        }

        .message.system {
            background: #1e2b44;
            align-self: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .message img, .message video, .message audio {
            max-width: 100%;
            border-radius: 0.5rem;
            margin-top: 0.3rem;
        }

        /* ========== Ø´Ø±ÙŠØ· Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ========== */
        .input-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
        }

        .input-row input {
            flex: 1;
            padding: 1rem;
            border: none;
            border-radius: 2rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--bg-tertiary);
            transition: var(--transition);
        }

        .input-row input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 10px var(--accent-primary);
        }

        .input-row button {
            width: 3.5rem;
            border-radius: 2rem;
            border: none;
            background: linear-gradient(145deg, var(--accent-primary), #a855f7);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .input-row button:hover {
            transform: scale(1.05);
        }

        /* ========== Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª ========== */
        .action-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .action-btn {
            flex: 1;
            padding: 0.8rem;
            border-radius: 2rem;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.3rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .action-btn:hover:not(:disabled) {
            background: #3a4a6b;
            transform: translateY(-2px);
        }

        .action-btn:disabled {
            opacity: 0.5;
        }

        /* ========== Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… ========== */
        .progress-bar {
            height: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 1rem;
            overflow: hidden;
            margin: 0.8rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--accent-primary), var(--accent-secondary));
            width: 0%;
            transition: width 0.3s;
        }

        /* ========== Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ========== */
        .stats {
            display: flex;
            justify-content: space-around;
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 0.8rem;
            margin-bottom: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 1rem;
            font-weight: bold;
            color: var(--accent-primary);
        }

        /* ========== Ø§Ù„ØªØ°ÙŠÙŠÙ„ ========== */
        .footer {
            text-align: center;
            margin-top: 1rem;
            color: #4b5563;
            font-size: 0.7rem;
        }

        /* ========== Ø¥Ø¶Ø§ÙØ§Øª Ù„Ù„ØªØ³Ø¬ÙŠÙ„ ÙˆØ§Ù„Ù…ÙƒØªØ¨Ø© ========== */
        .record-row {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .record-btn {
            flex: 1;
            padding: 0.8rem;
            border-radius: 2rem;
            border: none;
            background: var(--accent-primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
        }

        .record-btn.stop {
            background: var(--error);
        }

        .library {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 1rem;
            margin: 1rem 0;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .library-list {
            max-height: 8rem;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: var(--border-radius-md);
            padding: 0.5rem;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem;
            border-bottom: 1px solid var(--bg-tertiary);
            font-size: 0.8rem;
        }

        .library-item button {
            background: var(--accent-primary);
            border: none;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            margin-right: 0.3rem;
        }

        .library-item button.delete {
            background: var(--error);
        }

        .hidden {
            display: none !important;
        }

        .bit-indicator {
            background: var(--bg-secondary);
            padding: 0.5rem;
            border-radius: 2rem;
            text-align: center;
            font-size: 0.8rem;
            margin: 0.5rem 0;
        }
    </style>
</head>
<body>
    <div class="phone" id="app">
        <!-- Ø§Ù„Ù‡ÙŠØ¯Ø± -->
        <div class="header">
            <h1>ğŸ“¡ Ø±Ø§Ø³Ù„</h1>
            <div class="badge-container">
                <span class="badge">ØªØ±Ø¯Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„</span>
                <span class="badge">ØµÙˆØ± ÙˆÙÙŠØ¯ÙŠÙˆ</span>
                <span class="badge">ØªØ³Ø¬ÙŠÙ„</span>
            </div>
        </div>

        <!-- Ø§Ø®ØªÙŠØ§Ø± ÙˆØ¶Ø¹ Ø§Ù„ØªØ±Ø¯Ø¯ -->
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="ultrasonic">ğŸ”Š ÙÙˆÙ‚ ØµÙˆØªÙŠ</button>
            <button class="mode-btn" data-mode="audible">ğŸ‘‚ Ù…Ø³Ù…ÙˆØ¹</button>
        </div>

        <!-- Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØªØ±Ø¯Ø¯ -->
        <div class="freq-panel">
            <div class="freq-row">
                <span class="freq-label">Ø§Ù„ØªØ±Ø¯Ø¯ 0</span>
                <input type="range" id="freq0" min="100" max="22000" step="100" value="19000">
                <span class="freq-value" id="freq0Val">19000</span>
            </div>
            <div class="freq-row">
                <span class="freq-label">Ø§Ù„ØªØ±Ø¯Ø¯ 1</span>
                <input type="range" id="freq1" min="100" max="22000" step="100" value="20000">
                <span class="freq-value" id="freq1Val">20000</span>
            </div>
            <div class="freq-row">
                <span class="freq-label">Ù…Ø¯Ø© Ø§Ù„Ø¨Øª</span>
                <input type="range" id="bitDuration" min="4" max="100" step="1" value="8">
                <span class="freq-value" id="bitDurVal">8ms</span>
            </div>
        </div>

        <!-- ÙÙŠØ¬ÙˆØ§Ù„Ø§ÙŠØ²Ø± -->
        <div class="visualizer">
            <div class="wave-container" id="waveBars"></div>
            <div class="freq-indicator">
                <span>F0: <span id="freq0Display">19000</span> Hz</span>
                <span>F1: <span id="freq1Display">20000</span> Hz</span>
            </div>
            <div class="db-meter">
                <span>ğŸ“Š</span>
                <div class="bar"><div class="fill" id="dbFill"></div></div>
                <span class="db-value" id="dbValue">-âˆ dB</span>
            </div>
        </div>

        <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ (ÙŠØ¸Ù‡Ø± Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„) -->
        <div class="bit-indicator" id="bitIndicator">â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -</div>

        <!-- Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Ù…Ø±Ø³Ù„Ø©</div>
                <div class="stat-value" id="sentCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ù…Ø³ØªÙ‚Ø¨Ù„Ø©</div>
                <div class="stat-value" id="receivedCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ø£Ø®Ø·Ø§Ø¡</div>
                <div class="stat-value" id="errorCount">0</div>
            </div>
        </div>

        <!-- Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© -->
        <div class="status-bar">
            <span>ğŸ“¡ Ø§Ù„Ø­Ø§Ù„Ø©</span>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span id="statusText">Ø®Ø§Ù…Ù„</span>
                <span class="led" id="led"></span>
            </div>
        </div>

        <!-- Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© -->
        <div class="button-grid">
            <button class="btn primary" id="startListenBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø§Ø¹</button>
            <button class="btn" id="stopListenBtn">â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
            <button class="btn" id="testMsgBtn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø±</button>
            <button class="btn" id="clearChatBtn">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
        </div>

        <!-- Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… -->
        <div class="progress-bar hidden" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© -->
        <div class="chat-area">
            <div class="messages" id="messages"></div>
            <div class="input-row">
                <input type="text" id="messageInput" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„Ø©...">
                <button id="sendBtn">â¡ï¸</button>
            </div>
            <div class="action-row">
                <button class="action-btn" id="attachImageBtn">ğŸ“· ØµÙˆØ±Ø©</button>
                <button class="action-btn" id="attachVideoBtn">ğŸ¥ ÙÙŠØ¯ÙŠÙˆ</button>
                <button class="action-btn" id="recordAudioBtn">ğŸ¤ ØªØ³Ø¬ÙŠÙ„</button>
                <button class="action-btn" id="sendAudioBtn" disabled>â³ Ø³Ø¬Ù„ Ø£ÙˆÙ„Ø§Ù‹</button>
            </div>
        </div>

        <!-- Ù…Ù„ÙØ§Øª Ø®ÙÙŠØ© -->
        <input type="file" id="imageInput" accept="image/*" class="hidden">
        <input type="file" id="videoInput" accept="video/*" class="hidden">

        <!-- ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø© -->
        <div class="record-row">
            <button class="record-btn" id="startLibraryRecord">âºï¸ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
            <button class="record-btn stop" id="stopLibraryRecord" disabled>â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
        </div>
        <div class="record-row">
            <label for="audioFileInput" class="record-btn" style="background: var(--bg-tertiary);">ğŸ“‚ Ø±ÙØ¹ Ù…Ù„Ù</label>
            <button class="record-btn" id="decodeFileBtn" disabled>ğŸ”“ ÙÙƒ</button>
        </div>
        <input type="file" id="audioFileInput" accept="audio/*" class="hidden">

        <!-- Ø§Ù„Ù…ÙƒØªØ¨Ø© -->
        <div class="library">
            <div class="library-header">
                <span>ğŸ“š Ø§Ù„Ù…ÙƒØªØ¨Ø©</span>
                <button class="record-btn" id="refreshLibrary" style="padding: 0.3rem 1rem; font-size: 0.8rem;">âŸ³ ØªØ­Ø¯ÙŠØ«</button>
            </div>
            <div class="library-list" id="libraryList">
                <div class="message system">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>
            </div>
        </div>

        <div class="footer">
            âš¡ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Goertzel â€¢ v3.0 (Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ø­ØªØ±Ø§ÙÙŠØ©)
        </div>
    </div>

    <script>
        (function() {
            'use strict';

            // ================================
            // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (Ø«ÙˆØ§Ø¨Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚)
            // ================================
            const CONFIG = {
                SAMPLE_RATE: 48000,
                FFT_SIZE: 4096,
                PREAMBLE: [0xAA, 0x55, 0xAA, 0x55, 0xAA], // 5 bytes
                REPETITION: 2,        // ØªÙƒØ±Ø§Ø± ÙƒÙ„ Ø¨Ø§ÙŠØª Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                CHUNK_SIZE: 200,       // Ø­Ø¬Ù… Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù„ÙØ§Øª (Ø¨Ø§Ù„Ø£Ø­Ø±Ù base64)
                BIT_DURATION: 0.008,   // Ø«Ø§Ù†ÙŠØ© (8ms) â€“ ÙŠØªÙ… ØªØ­Ø¯ÙŠØ«Ù‡ Ù…Ù† Ø§Ù„Ø³Ù„Ø§ÙŠØ¯Ø±
                FREQ_0: 19000,
                FREQ_1: 20000,
                THRESHOLD: 0.015,       // Ø¹ØªØ¨Ø© Ø§Ù„ÙƒØ´Ù
                TOLERANCE: 2,            // Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø© ÙÙŠ preamble
                MUTE_WHEN_SENDING: true,
                // Ù…Ø­Ø³ÙˆØ¨
                get samplesPerBit() {
                    return Math.floor(this.SAMPLE_RATE * this.BIT_DURATION);
                }
            };

            // ================================
            // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠ (IndexedDB Ù„Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª)
            // ================================
            class RecordingDB {
                constructor() {
                    this.dbName = 'RaselDB';
                    this.storeName = 'recordings';
                    this.db = null;
                }

                async open() {
                    if (this.db) return this.db;
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => {
                            this.db = request.result;
                            resolve(this.db);
                        };
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains(this.storeName)) {
                                db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                            }
                        };
                    });
                }

                async save(blob, name) {
                    const db = await this.open();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(this.storeName, 'readwrite');
                        const store = tx.objectStore(this.storeName);
                        const record = {
                            name: name || `ØªØ³Ø¬ÙŠÙ„ ${new Date().toLocaleString()}`,
                            blob: blob,
                            type: blob.type,
                            size: blob.size,
                            timestamp: Date.now()
                        };
                        const request = store.add(record);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                }

                async getAll() {
                    const db = await this.open();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(this.storeName, 'readonly');
                        const store = tx.objectStore(this.storeName);
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                }

                async delete(id) {
                    const db = await this.open();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(this.storeName, 'readwrite');
                        const store = tx.objectStore(this.storeName);
                        const request = store.delete(id);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }
            }

            // ================================
            // Ù‚Ù„Ø¨ Ø§Ù„Ù†Ø¸Ø§Ù…: Ø§Ù„Ù…ÙˆØ¯Ù… Ø§Ù„ØµÙˆØªÙŠ (AudioModem)
            // ================================
            class AudioModem {
                constructor(config) {
                    this.config = config;
                    this.audioCtx = null;
                    this.isListening = false;
                    this.isSending = false;
                    this.mediaStream = null;
                    this.analyser = null;
                    this.gainNode = null;
                    this.mediaSource = null;

                    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„
                    this.rxState = {
                        phase: 'IDLE', // IDLE, PREAMBLE, LENGTH, DATA, CHECKSUM
                        preambleBits: '',
                        lengthBits: '',
                        dataBits: '',
                        checksumBits: '',
                        expectedLength: 0,
                        dataBytes: [],
                        lastBitTime: 0,
                        bitsBuffer: ''
                    };

                    // callbacks
                    this.onBitDetected = null;
                    this.onMessageReceived = null;
                    this.onFileChunk = null;
                    this.onFileComplete = null;
                    this.onStatusChange = null;
                    this.onWaveUpdate = null;
                    this.onDbUpdate = null;
                    this.onSendingProgress = null;
                    this.onSendingComplete = null;
                    this.onError = null;
                }

                // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„ØµÙˆØªÙŠ
                async initContext() {
                    if (this.audioCtx && this.audioCtx.state !== 'closed') return this.audioCtx;
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.config.SAMPLE_RATE
                    });
                    if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();
                    return this.audioCtx;
                }

                // Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹
                async startListening() {
                    if (this.isListening) return;
                    try {
                        const ctx = await this.initContext();
                        this.mediaStream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                echoCancellation: false,
                                noiseSuppression: false,
                                autoGainControl: false
                            }
                        });
                        this.mediaSource = ctx.createMediaStreamSource(this.mediaStream);
                        this.analyser = ctx.createAnalyser();
                        this.analyser.fftSize = this.config.FFT_SIZE;
                        this.analyser.smoothingTimeConstant = 0.2;
                        this.gainNode = ctx.createGain();
                        this.gainNode.gain.value = 1;

                        this.mediaSource.connect(this.analyser);
                        this.analyser.connect(this.gainNode);
                        this.gainNode.connect(ctx.destination);

                        this.isListening = true;
                        this.resetRxState();
                        this.onStatusChange?.('listening', 'ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹');

                        // Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª
                        this._startVisualUpdates();

                        // Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø¨ØªØ§Øª
                        this._startBitDetection();

                    } catch (err) {
                        this.onError?.(err);
                        this.isListening = false;
                        throw err;
                    }
                }

                // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹
                stopListening() {
                    if (!this.isListening) return;
                    this.isListening = false;
                    if (this.mediaSource) {
                        this.mediaSource.disconnect();
                        this.mediaStream.getTracks().forEach(t => t.stop());
                    }
                    this.analyser = null;
                    this.mediaSource = null;
                    this.mediaStream = null;
                    if (this._visualFrame) cancelAnimationFrame(this._visualFrame);
                    if (this._detectInterval) clearInterval(this._detectInterval);
                    this.onStatusChange?.('idle', 'Ø®Ø§Ù…Ù„');
                    this.resetRxState();
                }

                // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„
                resetRxState() {
                    this.rxState = {
                        phase: 'IDLE',
                        preambleBits: '',
                        lengthBits: '',
                        dataBits: '',
                        checksumBits: '',
                        expectedLength: 0,
                        dataBytes: [],
                        lastBitTime: 0,
                        bitsBuffer: ''
                    };
                }

                // ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¨ØµØ±ÙŠØ© (Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª ÙˆØ§Ù„Ù…ÙˆØ¬Ø§Øª)
                _startVisualUpdates() {
                    const update = () => {
                        if (!this.isListening || !this.analyser) return;
                        // Ù…Ø³ØªÙˆÙ‰ dB
                        const dataArray = new Float32Array(this.analyser.frequencyBinCount);
                        this.analyser.getFloatTimeDomainData(dataArray);
                        let sum = 0;
                        for (let i = 0; i < dataArray.length; i++) sum += dataArray[i] * dataArray[i];
                        const rms = Math.sqrt(sum / dataArray.length);
                        const db = 20 * Math.log10(rms + 1e-10);
                        const normalized = Math.min(1, Math.max(0, (db + 100) / 60));
                        this.onDbUpdate?.(normalized, db);

                        // Ù…ÙˆØ¬Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ù„Ø­Ø±ÙƒØ©
                        this.onWaveUpdate?.(0.3 + Math.random() * 0.3);

                        this._visualFrame = requestAnimationFrame(update);
                    };
                    this._visualFrame = requestAnimationFrame(update);
                }

                // ÙƒØ´Ù Ø§Ù„Ø¨ØªØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Goertzel
                _startBitDetection() {
                    const samplesPerBit = this.config.samplesPerBit;
                    const bufferSize = 2048;
                    const inputBuffer = new Float32Array(bufferSize);

                    this._detectInterval = setInterval(() => {
                        if (!this.isListening || !this.analyser) return;

                        this.analyser.getFloatTimeDomainData(inputBuffer);
                        // Ù†Ø£Ø®Ø° Ø¢Ø®Ø± samplesPerBit Ø¹ÙŠÙ†Ø© (Ø£Ùˆ Ø£Ù‚Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙˆÙØ±)
                        const start = Math.max(0, inputBuffer.length - samplesPerBit);
                        const samples = inputBuffer.slice(start);

                        if (samples.length < samplesPerBit * 0.8) return;

                        const bit = this._detectBit(samples);
                        this._processBit(bit);

                    }, this.config.BIT_DURATION * 1000 * 0.9); // Ø£Ù‚Ù„ Ø¨Ù‚Ù„ÙŠÙ„ Ù…Ù† Ù…Ø¯Ø© Ø§Ù„Ø¨Øª
                }

                // ÙƒØ´Ù Ø¨Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Goertzel
                _detectBit(samples) {
                    const energy0 = this._goertzel(samples, this.config.FREQ_0);
                    const energy1 = this._goertzel(samples, this.config.FREQ_1);
                    return (energy1 / (energy0 + 1e-10)) > this.config.THRESHOLD ? 1 : 0;
                }

                _goertzel(samples, targetFreq) {
                    const N = samples.length;
                    const coeff = 2 * Math.cos(2 * Math.PI * targetFreq / this.config.SAMPLE_RATE);
                    let sPrev = 0, sPrev2 = 0;
                    for (let i = 0; i < N; i++) {
                        // Ù†Ø§ÙØ°Ø© Ù‡Ø§Ù…ÙŠÙ†Øº
                        const windowVal = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1));
                        const sample = samples[i] * windowVal;
                        const s = sample + coeff * sPrev - sPrev2;
                        sPrev2 = sPrev;
                        sPrev = s;
                    }
                    return sPrev2 * sPrev2 + sPrev * sPrev - coeff * sPrev * sPrev2;
                }

                // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨Øª Ø§Ù„ÙˆØ§Ø±Ø¯
                _processBit(bit) {
                    const now = Date.now();
                    if (now - this.rxState.lastBitTime < this.config.BIT_DURATION * 1000 * 0.5) return;
                    this.rxState.lastBitTime = now;

                    this.rxState.bitsBuffer += bit;

                    // Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª
                    if (this.rxState.phase === 'IDLE') {
                        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† preamble
                        this.rxState.preambleBits += bit;
                        if (this.rxState.preambleBits.length > 80) {
                            this.rxState.preambleBits = this.rxState.preambleBits.slice(-40);
                        }
                        const preambleBinary = this.config.PREAMBLE.map(b => b.toString(2).padStart(8, '0')).join('');
                        if (this.rxState.preambleBits.length >= preambleBinary.length) {
                            const candidate = this.rxState.preambleBits.slice(-preambleBinary.length);
                            const distance = this._hammingDistance(candidate, preambleBinary);
                            if (distance <= this.config.TOLERANCE) {
                                this.rxState.phase = 'LENGTH';
                                this.rxState.preambleBits = '';
                                this.rxState.lengthBits = '';
                                this.onStatusChange?.('receiving', 'ØªÙ… ÙƒØ´Ù preamble');
                            }
                        }
                    } else if (this.rxState.phase === 'LENGTH') {
                        this.rxState.lengthBits += bit;
                        if (this.rxState.lengthBits.length === 8) {
                            this.rxState.expectedLength = parseInt(this.rxState.lengthBits, 2);
                            this.rxState.phase = 'DATA';
                            this.rxState.dataBits = '';
                            this.rxState.dataBytes = [];
                        }
                    } else if (this.rxState.phase === 'DATA') {
                        this.rxState.dataBits += bit;
                        while (this.rxState.dataBits.length >= 8) {
                            const byteBits = this.rxState.dataBits.substring(0, 8);
                            this.rxState.dataBits = this.rxState.dataBits.substring(8);
                            const byte = parseInt(byteBits, 2);
                            this.rxState.dataBytes.push(byte);
                        }
                        if (this.rxState.dataBytes.length >= this.rxState.expectedLength * this.config.REPETITION) {
                            this.rxState.phase = 'CHECKSUM';
                            this.rxState.checksumBits = '';
                        }
                    } else if (this.rxState.phase === 'CHECKSUM') {
                        this.rxState.checksumBits += bit;
                        if (this.rxState.checksumBits.length === 8) {
                            const receivedChecksum = parseInt(this.rxState.checksumBits, 2);
                            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
                            const finalBytes = [];
                            for (let i = 0; i < this.rxState.expectedLength; i++) {
                                const repeats = [];
                                for (let r = 0; r < this.config.REPETITION; r++) {
                                    repeats.push(this.rxState.dataBytes[i * this.config.REPETITION + r]);
                                }
                                finalBytes.push(this._majorityVote(repeats));
                            }
                            let calcChecksum = this.rxState.expectedLength;
                            for (let b of finalBytes) calcChecksum ^= b;

                            if (receivedChecksum === calcChecksum) {
                                // Ù†Ø¬Ø§Ø­
                                const text = new TextDecoder().decode(new Uint8Array(finalBytes));
                                this.onMessageReceived?.(text);
                            } else {
                                this.onError?.(new Error('Checksum mismatch'));
                            }
                            // Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
                            this.rxState.phase = 'IDLE';
                            this.rxState.preambleBits = '';
                        }
                    }
                }

                _hammingDistance(a, b) {
                    if (a.length !== b.length) return Infinity;
                    let dist = 0;
                    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) dist++;
                    return dist;
                }

                _majorityVote(arr) {
                    const counts = {};
                    for (let v of arr) counts[v] = (counts[v] || 0) + 1;
                    return parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));
                }

                // ========== Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ ==========
                async sendBytes(bytes) {
                    if (this.isSending) throw new Error('ÙŠÙˆØ¬Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ°');
                    this.isSending = true;
                    this.onStatusChange?.('sending', 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...');

                    if (this.config.MUTE_WHEN_SENDING && this.gainNode) {
                        this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                    }

                    try {
                        const ctx = await this.initContext();
                        const buffer = this._createWaveform(bytes);
                        const source = ctx.createBufferSource();
                        source.buffer = buffer;
                        source.connect(ctx.destination);
                        source.start();

                        const durationMs = (buffer.length / this.config.SAMPLE_RATE) * 1000;
                        const start = Date.now();

                        const progressInterval = setInterval(() => {
                            const elapsed = Date.now() - start;
                            const prog = Math.min(1, elapsed / durationMs);
                            this.onSendingProgress?.(prog);
                            if (prog >= 1) {
                                clearInterval(progressInterval);
                                this.isSending = false;
                                this.onStatusChange?.('listening', 'ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹');
                                this.onSendingComplete?.();
                                if (this.config.MUTE_WHEN_SENDING && this.gainNode) {
                                    this.gainNode.gain.setValueAtTime(1, this.audioCtx.currentTime);
                                }
                            }
                        }, 50);

                        source.onended = () => {
                            clearInterval(progressInterval);
                            this.isSending = false;
                            this.onStatusChange?.('listening', 'ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹');
                            this.onSendingComplete?.();
                            if (this.config.MUTE_WHEN_SENDING && this.gainNode) {
                                this.gainNode.gain.setValueAtTime(1, this.audioCtx.currentTime);
                            }
                        };

                    } catch (err) {
                        this.isSending = false;
                        this.onError?.(err);
                        throw err;
                    }
                }

                _createWaveform(bytes) {
                    const samplesPerBit = this.config.samplesPerBit;
                    const totalBits = bytes.length * 8;
                    const totalSamples = totalBits * samplesPerBit;
                    const buffer = this.audioCtx.createBuffer(1, totalSamples, this.config.SAMPLE_RATE);
                    const channel = buffer.getChannelData(0);

                    const hanning = (i, len) => 0.5 * (1 - Math.cos(2 * Math.PI * i / (len - 1)));

                    let idx = 0;
                    for (let byte of bytes) {
                        for (let i = 7; i >= 0; i--) {
                            const bit = (byte >> i) & 1;
                            const freq = bit ? this.config.FREQ_1 : this.config.FREQ_0;
                            const omega = 2 * Math.PI * freq / this.config.SAMPLE_RATE;
                            // Ù†Ù…Ø±Ø± Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
                            this.onBitUpdate?.(bit, freq);
                            for (let s = 0; s < samplesPerBit; s++) {
                                // ØªØ·Ø¨ÙŠÙ‚ Ù†Ø§ÙØ°Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù†Ù‚Ø±Ø§Øª
                                let windowFactor = 1;
                                if (s < samplesPerBit * 0.1) {
                                    windowFactor = hanning(s, samplesPerBit * 0.1);
                                } else if (s > samplesPerBit * 0.9) {
                                    windowFactor = hanning(samplesPerBit - s - 1, samplesPerBit * 0.1);
                                }
                                channel[idx++] = Math.sin(omega * s) * windowFactor * 0.9;
                            }
                        }
                    }
                    return buffer;
                }

                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
                updateConfig(newConfig) {
                    Object.assign(this.config, newConfig);
                }
            }

            // ================================
            // Ù…Ø¯ÙŠØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (UIController)
            // ================================
            class UIController {
                constructor(modem, db) {
                    this.modem = modem;
                    this.db = db;

                    // Ø¹Ù†Ø§ØµØ± DOM
                    this.freq0Slider = document.getElementById('freq0');
                    this.freq1Slider = document.getElementById('freq1');
                    this.freq0Val = document.getElementById('freq0Val');
                    this.freq1Val = document.getElementById('freq1Val');
                    this.bitDurationSlider = document.getElementById('bitDuration');
                    this.bitDurVal = document.getElementById('bitDurVal');
                    this.freq0Display = document.getElementById('freq0Display');
                    this.freq1Display = document.getElementById('freq1Display');
                    this.dbFill = document.getElementById('dbFill');
                    this.dbValue = document.getElementById('dbValue');
                    this.waveBars = document.getElementById('waveBars');
                    this.sentCountEl = document.getElementById('sentCount');
                    this.receivedCountEl = document.getElementById('receivedCount');
                    this.errorCountEl = document.getElementById('errorCount');
                    this.messagesDiv = document.getElementById('messages');
                    this.messageInput = document.getElementById('messageInput');
                    this.sendBtn = document.getElementById('sendBtn');
                    this.startListenBtn = document.getElementById('startListenBtn');
                    this.stopListenBtn = document.getElementById('stopListenBtn');
                    this.testMsgBtn = document.getElementById('testMsgBtn');
                    this.clearChatBtn = document.getElementById('clearChatBtn');
                    this.attachImageBtn = document.getElementById('attachImageBtn');
                    this.attachVideoBtn = document.getElementById('attachVideoBtn');
                    this.recordAudioBtn = document.getElementById('recordAudioBtn');
                    this.sendAudioBtn = document.getElementById('sendAudioBtn');
                    this.imageInput = document.getElementById('imageInput');
                    this.videoInput = document.getElementById('videoInput');
                    this.statusText = document.getElementById('statusText');
                    this.led = document.getElementById('led');
                    this.progressBar = document.getElementById('progressBar');
                    this.progressFill = document.getElementById('progressFill');
                    this.bitIndicator = document.getElementById('bitIndicator');
                    this.modeUltrasonic = document.querySelector('[data-mode="ultrasonic"]');
                    this.modeAudible = document.querySelector('[data-mode="audible"]');
                    this.startLibraryRecord = document.getElementById('startLibraryRecord');
                    this.stopLibraryRecord = document.getElementById('stopLibraryRecord');
                    this.audioFileInput = document.getElementById('audioFileInput');
                    this.decodeFileBtn = document.getElementById('decodeFileBtn');
                    this.libraryList = document.getElementById('libraryList');
                    this.refreshLibrary = document.getElementById('refreshLibrary');

                    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                    this.stats = { sent: 0, received: 0, errors: 0 };

                    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø¤Ù‚Øª
                    this.mediaRecorder = null;
                    this.audioChunks = [];
                    this.recordedBlob = null;

                    // Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
                    this._bindEvents();

                    // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø´Ø±Ø·Ø© Ø§Ù„Ù…ÙˆØ¬Ø©
                    this._initWaveBars();

                    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
                    this._loadConfig();

                    // Ø±Ø¨Ø· callback Ø§Ù„Ù…ÙˆØ¯Ù…
                    this._connectModemCallbacks();
                }

                _bindEvents() {
                    // Ø§Ù„Ø³Ù„Ø§ÙŠØ¯Ø±Ø§Øª
                    this.freq0Slider.addEventListener('input', () => this._updateFreqFromSlider());
                    this.freq1Slider.addEventListener('input', () => this._updateFreqFromSlider());
                    this.bitDurationSlider.addEventListener('input', () => this._updateBitDuration());

                    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£ÙˆØ¶Ø§Ø¹
                    this.modeUltrasonic.addEventListener('click', () => this._setMode('ultrasonic'));
                    this.modeAudible.addEventListener('click', () => this._setMode('audible'));

                    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
                    this.startListenBtn.addEventListener('click', () => this.modem.startListening().catch(e => this._handleError(e)));
                    this.stopListenBtn.addEventListener('click', () => this.modem.stopListening());
                    this.testMsgBtn.addEventListener('click', () => this._sendTestMessage());
                    this.clearChatBtn.addEventListener('click', () => this._clearChat());
                    this.sendBtn.addEventListener('click', () => this._sendText());
                    this.messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') this._sendText(); });

                    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙˆØ³Ø§Ø¦Ø·
                    this.attachImageBtn.addEventListener('click', () => this.imageInput.click());
                    this.attachVideoBtn.addEventListener('click', () => this.videoInput.click());
                    this.imageInput.addEventListener('change', (e) => this._sendFile(e.target.files[0], 'ØµÙˆØ±Ø©'));
                    this.videoInput.addEventListener('change', (e) => this._sendFile(e.target.files[0], 'ÙÙŠØ¯ÙŠÙˆ'));

                    // ØªØ³Ø¬ÙŠÙ„ ØµÙˆØªÙŠ
                    this.recordAudioBtn.addEventListener('click', () => this._toggleAudioRecording());
                    this.sendAudioBtn.addEventListener('click', () => this._sendAudio());

                    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©
                    this.startLibraryRecord.addEventListener('click', () => this._startLibraryRecording());
                    this.stopLibraryRecord.addEventListener('click', () => this._stopLibraryRecording());
                    this.audioFileInput.addEventListener('change', () => {
                        this.decodeFileBtn.disabled = !this.audioFileInput.files[0];
                    });
                    this.decodeFileBtn.addEventListener('click', () => this._decodeAudioFile());
                    this.refreshLibrary.addEventListener('click', () => this._loadLibrary());

                    // Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ Ù„Ù„Ù…ÙƒØªØ¨Ø©
                    this._loadLibrary();
                }

                _initWaveBars() {
                    for (let i = 0; i < 14; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'wave-bar';
                        this.waveBars.appendChild(bar);
                    }
                    this.waveBars = document.querySelectorAll('.wave-bar');
                }

                _connectModemCallbacks() {
                    this.modem.onStatusChange = (state, text) => {
                        this.statusText.innerText = text;
                        this.led.className = `led ${state === 'listening' ? 'listening' : state === 'sending' ? 'sending' : ''}`;
                    };

                    this.modem.onDbUpdate = (normalized, db) => {
                        this.dbFill.style.width = (normalized * 100) + '%';
                        this.dbValue.textContent = db.toFixed(1) + ' dB';
                    };

                    this.modem.onWaveUpdate = (energy) => {
                        const active = Math.floor(energy * this.waveBars.length);
                        this.waveBars.forEach((bar, i) => {
                            if (i < active) {
                                bar.style.height = 30 + energy * 50 + 'px';
                                bar.classList.add('active');
                            } else {
                                bar.style.height = '20px';
                                bar.classList.remove('active');
                            }
                        });
                    };

                    this.modem.onBitUpdate = (bit, freq) => {
                        this.bitIndicator.textContent = `ğŸ”Š Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: ${bit} (ØªØ±Ø¯Ø¯ ${freq} Hz)`;
                    };

                    this.modem.onMessageReceived = (text) => {
                        this._addMessage(text, 'received');
                        this.stats.received++;
                        this._updateStats();
                    };

                    this.modem.onError = (err) => {
                        this.stats.errors++;
                        this._updateStats();
                        this._addMessage(`âŒ Ø®Ø·Ø£: ${err.message}`, 'system');
                    };

                    this.modem.onSendingProgress = (prog) => {
                        this.progressBar.classList.remove('hidden');
                        this.progressFill.style.width = (prog * 100) + '%';
                    };

                    this.modem.onSendingComplete = () => {
                        this.progressBar.classList.add('hidden');
                        this.bitIndicator.textContent = 'â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -';
                    };
                }

                _updateFreqFromSlider() {
                    const f0 = parseInt(this.freq0Slider.value);
                    const f1 = parseInt(this.freq1Slider.value);
                    // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø®ØªÙ„Ø§Ù Ø§Ù„ØªØ±Ø¯Ø¯ÙŠÙ†
                    if (f0 === f1) {
                        if (f1 < 22000) this.freq1Slider.value = f1 + 100;
                        else this.freq1Slider.value = f1 - 100;
                    }
                    const newF0 = parseInt(this.freq0Slider.value);
                    const newF1 = parseInt(this.freq1Slider.value);
                    this.freq0Val.textContent = newF0;
                    this.freq1Val.textContent = newF1;
                    this.freq0Display.textContent = newF0;
                    this.freq1Display.textContent = newF1;
                    this.modem.updateConfig({ FREQ_0: newF0, FREQ_1: newF1 });
                    this._saveConfig();
                }

                _updateBitDuration() {
                    const val = parseInt(this.bitDurationSlider.value);
                    this.bitDurVal.textContent = val + 'ms';
                    const bitDur = val / 1000;
                    this.modem.updateConfig({ BIT_DURATION: bitDur });
                    this._saveConfig();
                }

                _setMode(mode) {
                    if (mode === 'ultrasonic') {
                        this.modeUltrasonic.classList.add('active');
                        this.modeAudible.classList.remove('active');
                        this.freq0Slider.value = 19000;
                        this.freq1Slider.value = 20000;
                    } else {
                        this.modeAudible.classList.add('active');
                        this.modeUltrasonic.classList.remove('active');
                        this.freq0Slider.value = 500;
                        this.freq1Slider.value = 1000;
                    }
                    this._updateFreqFromSlider();
                }

                _sendText() {
                    const text = this.messageInput.value.trim();
                    if (!text) return;
                    this._addMessage(text, 'sent');
                    this.stats.sent++;
                    this._updateStats();
                    this.messageInput.value = '';

                    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ Ø¨Ø§ÙŠØªØ§Øª ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„
                    const bytes = new TextEncoder().encode(text);
                    const frame = this._encodeFrame(bytes);
                    this.modem.sendBytes(frame).catch(e => this._handleError(e));
                }

                _encodeFrame(bytes) {
                    let frame = [...this.modem.config.PREAMBLE];
                    frame.push(bytes.length);
                    for (let b of bytes) {
                        for (let r = 0; r < this.modem.config.REPETITION; r++) frame.push(b);
                    }
                    let checksum = bytes.length;
                    for (let b of bytes) checksum ^= b;
                    frame.push(checksum);
                    return new Uint8Array(frame);
                }

                _sendTestMessage() {
                    this.messageInput.value = 'ğŸ¤ Ø§Ø®ØªØ¨Ø§Ø±: Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…!';
                    this._sendText();
                }

                _clearChat() {
                    this.messagesDiv.innerHTML = '<div class="message system">âœ¨ ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©</div>';
                    this.stats = { sent: 0, received: 0, errors: 0 };
                    this._updateStats();
                }

                _addMessage(text, type, isHtml = false) {
                    const msg = document.createElement('div');
                    msg.classList.add('message', type);
                    if (isHtml) msg.innerHTML = text;
                    else msg.textContent = text;
                    this.messagesDiv.appendChild(msg);
                    this.messagesDiv.scrollTop = this.messagesDiv.scrollHeight;
                }

                _updateStats() {
                    this.sentCountEl.textContent = this.stats.sent;
                    this.receivedCountEl.textContent = this.stats.received;
                    this.errorCountEl.textContent = this.stats.errors;
                }

                _handleError(err) {
                    console.error(err);
                    this.stats.errors++;
                    this._updateStats();
                    this._addMessage(`âš ï¸ Ø®Ø·Ø£: ${err.message}`, 'system');
                }

                _saveConfig() {
                    const config = {
                        FREQ_0: this.modem.config.FREQ_0,
                        FREQ_1: this.modem.config.FREQ_1,
                        BIT_DURATION: this.modem.config.BIT_DURATION,
                        THRESHOLD: this.modem.config.THRESHOLD,
                        TOLERANCE: this.modem.config.TOLERANCE
                    };
                    localStorage.setItem('raselConfig', JSON.stringify(config));
                }

                _loadConfig() {
                    try {
                        const saved = localStorage.getItem('raselConfig');
                        if (saved) {
                            const cfg = JSON.parse(saved);
                            this.freq0Slider.value = cfg.FREQ_0 || 19000;
                            this.freq1Slider.value = cfg.FREQ_1 || 20000;
                            this.bitDurationSlider.value = (cfg.BIT_DURATION || 0.008) * 1000;
                            this.modem.updateConfig(cfg);
                            this._updateFreqFromSlider();
                            this._updateBitDuration();
                        }
                    } catch (e) {}
                }

                // ========== Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª ==========
                async _sendFile(file, type) {
                    if (!file) return;
                    try {
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            const base64 = e.target.result.split(',')[1];
                            const chunkSize = this.modem.config.CHUNK_SIZE;
                            const totalChunks = Math.ceil(base64.length / chunkSize);
                            const transferId = Date.now().toString(36) + Math.random().toString(36).substring(2);

                            this._addMessage(`ğŸ–¼ï¸ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ ${type}: ${file.name} (${totalChunks} Ø¬Ø²Ø¡)`, 'system');

                            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
                            const meta = JSON.stringify({
                                type, id: transferId, name: file.name, mime: file.type,
                                size: base64.length, chunks: totalChunks
                            });
                            const metaBytes = new TextEncoder().encode('META:' + meta);
                            await this.modem.sendBytes(this._encodeFrame(metaBytes));

                            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = base64.substr(i * chunkSize, chunkSize);
                                const chunkData = `CHUNK:${transferId}:${i}:${chunk}`;
                                const chunkBytes = new TextEncoder().encode(chunkData);
                                await this.modem.sendBytes(this._encodeFrame(chunkBytes));
                                // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ Ø§Ø²Ø¯Ø­Ø§Ù… Ø§Ù„Ù…Ø®Ø²Ù† Ø§Ù„Ù…Ø¤Ù‚Øª
                                await new Promise(r => setTimeout(r, 100));
                            }
                            this.stats.sent++;
                            this._updateStats();
                            this._addMessage(`âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${type}`, 'system');
                        };
                        reader.readAsDataURL(file);
                    } catch (err) {
                        this._handleError(err);
                    }
                }

                // ========== Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ù…Ø¤Ù‚Øª (Ù„Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØª) ==========
                async _toggleAudioRecording() {
                    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                        this.mediaRecorder.stop();
                        this.recordAudioBtn.textContent = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„';
                        this.sendAudioBtn.disabled = true;
                        return;
                    }
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        this.mediaRecorder = new MediaRecorder(stream);
                        this.audioChunks = [];
                        this.mediaRecorder.ondataavailable = (e) => this.audioChunks.push(e.data);
                        this.mediaRecorder.onstop = () => {
                            this.recordedBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                            this.sendAudioBtn.disabled = false;
                            stream.getTracks().forEach(t => t.stop());
                            this._addMessage(`ğŸ¤ ØªÙ… ØªØ³Ø¬ÙŠÙ„ ${(this.recordedBlob.size / 1024).toFixed(1)} ÙƒÙŠÙ„ÙˆØ¨Ø§ÙŠØª`, 'system');
                        };
                        this.mediaRecorder.start();
                        this.recordAudioBtn.textContent = 'â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù';
                    } catch (err) {
                        this._handleError(err);
                    }
                }

                async _sendAudio() {
                    if (!this.recordedBlob) return;
                    await this._sendFile(this.recordedBlob, 'audio');
                    this.recordedBlob = null;
                    this.sendAudioBtn.disabled = true;
                }

                // ========== Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ù…ÙƒØªØ¨Ø© (IndexedDB) ==========
                async _startLibraryRecording() {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        this.libRecorder = new MediaRecorder(stream);
                        this.libChunks = [];
                        this.libRecorder.ondataavailable = (e) => this.libChunks.push(e.data);
                        this.libRecorder.onstop = async () => {
                            const blob = new Blob(this.libChunks, { type: 'audio/webm' });
                            const name = prompt('Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„', `ØªØ³Ø¬ÙŠÙ„ ${new Date().toLocaleString()}`);
                            await this.db.save(blob, name || 'ØªØ³Ø¬ÙŠÙ„');
                            this._loadLibrary();
                            stream.getTracks().forEach(t => t.stop());
                            this.startLibraryRecord.disabled = false;
                            this.stopLibraryRecord.disabled = true;
                        };
                        this.libRecorder.start();
                        this.startLibraryRecord.disabled = true;
                        this.stopLibraryRecord.disabled = false;
                    } catch (err) {
                        this._handleError(err);
                    }
                }

                _stopLibraryRecording() {
                    if (this.libRecorder && this.libRecorder.state === 'recording') {
                        this.libRecorder.stop();
                    }
                }

                async _decodeAudioFile() {
                    const file = this.audioFileInput.files[0];
                    if (!file) return;
                    try {
                        this._addMessage(`ğŸ” Ø¨Ø¯Ø¡ ÙÙƒ ØªØ´ÙÙŠØ± ${file.name}`, 'system');
                        const ctx = new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await file.arrayBuffer();
                        const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                        const channel = audioBuffer.getChannelData(0);

                        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ØªØ§Øª
                        const samplesPerBit = this.modem.config.samplesPerBit;
                        const numBits = Math.floor(channel.length / samplesPerBit);
                        let bits = '';
                        for (let i = 0; i < numBits; i++) {
                            const start = i * samplesPerBit;
                            const end = start + samplesPerBit;
                            const windowSamples = channel.slice(start, end);
                            const bit = this.modem._detectBit(windowSamples);
                            bits += bit;
                        }

                        // Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
                        const text = this._extractTextFromBits(bits);
                        if (text) {
                            this._addMessage(text, 'received');
                            this.stats.received++;
                            this._updateStats();
                        } else {
                            this._addMessage('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø©', 'system');
                        }
                    } catch (err) {
                        this._handleError(err);
                    } finally {
                        this.audioFileInput.value = '';
                        this.decodeFileBtn.disabled = true;
                    }
                }

                _extractTextFromBits(bits) {
                    const preambleBinary = this.modem.config.PREAMBLE.map(b => b.toString(2).padStart(8, '0')).join('');
                    let idx = bits.indexOf(preambleBinary);
                    if (idx === -1) return null;
                    bits = bits.substring(idx + preambleBinary.length);
                    if (bits.length < 8) return null;
                    const lengthBits = bits.substring(0, 8);
                    const expectedLength = parseInt(lengthBits, 2);
                    bits = bits.substring(8);
                    const totalDataBits = expectedLength * this.modem.config.REPETITION * 8;
                    if (bits.length < totalDataBits) return null;
                    const dataBits = bits.substring(0, totalDataBits);
                    bits = bits.substring(totalDataBits);
                    if (bits.length < 8) return null;
                    const checksumBits = bits.substring(0, 8);
                    const receivedChecksum = parseInt(checksumBits, 2);

                    let dataBytes = [];
                    for (let i = 0; i < totalDataBits; i += 8) {
                        const byteBits = dataBits.substring(i, i + 8);
                        dataBytes.push(parseInt(byteBits, 2));
                    }

                    const finalBytes = [];
                    for (let i = 0; i < expectedLength; i++) {
                        const repeats = [];
                        for (let r = 0; r < this.modem.config.REPETITION; r++) {
                            repeats.push(dataBytes[i * this.modem.config.REPETITION + r]);
                        }
                        finalBytes.push(this.modem._majorityVote(repeats));
                    }

                    let calcChecksum = expectedLength;
                    for (let b of finalBytes) calcChecksum ^= b;

                    if (receivedChecksum !== calcChecksum) return null;
                    return new TextDecoder().decode(new Uint8Array(finalBytes));
                }

                async _loadLibrary() {
                    try {
                        const recordings = await this.db.getAll();
                        this.libraryList.innerHTML = '';
                        if (recordings.length === 0) {
                            this.libraryList.innerHTML = '<div class="message system">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ³Ø¬ÙŠÙ„Ø§Øª</div>';
                            return;
                        }
                        recordings.sort((a, b) => b.timestamp - a.timestamp);
                        recordings.forEach(rec => {
                            const div = document.createElement('div');
                            div.className = 'library-item';
                            div.innerHTML = `
                                <span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${rec.name}</span>
                                <div>
                                    <button onclick="window.decodeRecording(${rec.id})">ğŸ”“</button>
                                    <button class="delete" onclick="window.deleteRecording(${rec.id})">ğŸ—‘ï¸</button>
                                </div>
                            `;
                            this.libraryList.appendChild(div);
                        });
                    } catch (err) {
                        console.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©', err);
                    }
                }
            }

            // ================================
            // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
            // ================================
            const modem = new AudioModem(CONFIG);
            const db = new RecordingDB();
            const ui = new UIController(modem, db);

            // Ø±Ø¨Ø· Ø¯ÙˆØ§Ù„ Ø§Ù„Ù†Ø§ÙØ°Ø© Ù„Ù„Ù…ÙƒØªØ¨Ø©
            window.decodeRecording = async (id) => {
                try {
                    const rec = (await db.getAll()).find(r => r.id === id);
                    if (rec && rec.blob) {
                        const file = new File([rec.blob], rec.name, { type: rec.blob.type });
                        await ui._decodeAudioFile(file); // Ù„ÙƒÙ† _decodeAudioFile ØªØªÙˆÙ‚Ø¹ Ù…Ù„Ù Ù…Ù† inputØŒ Ù„Ø°Ø§ Ù†Ù…Ø±Ø± Ø§Ù„Ù…Ù„Ù Ù…Ø¨Ø§Ø´Ø±Ø©ØŸ Ø³Ù†Ø¹Ø¯Ù„ Ù‚Ù„ÙŠÙ„Ø§Ù‹
                        // Ù„Ù„ØªØ¨Ø³ÙŠØ·ØŒ Ù†Ø¹ÙŠØ¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚:
                        const ctx = new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await rec.blob.arrayBuffer();
                        const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                        const channel = audioBuffer.getChannelData(0);
                        const samplesPerBit = CONFIG.samplesPerBit;
                        const numBits = Math.floor(channel.length / samplesPerBit);
                        let bits = '';
                        for (let i = 0; i < numBits; i++) {
                            const start = i * samplesPerBit;
                            const end = start + samplesPerBit;
                            const windowSamples = channel.slice(start, end);
                            const bit = modem._detectBit(windowSamples);
                            bits += bit;
                        }
                        const text = ui._extractTextFromBits(bits);
                        if (text) {
                            ui._addMessage(text, 'received');
                            ui.stats.received++;
                            ui._updateStats();
                        } else {
                            ui._addMessage('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø©', 'system');
                        }
                    }
                } catch (err) {
                    ui._handleError(err);
                }
            };

            window.deleteRecording = async (id) => {
                if (confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ØŸ')) {
                    await db.delete(id);
                    ui._loadLibrary();
                }
            };

        })();
    </script>
</body>
</html>