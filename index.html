<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù…ÙˆØ¬Ø© Ù…Ø®ØµØµØ© - Ù†Ø³Ø®Ø© Ù†Ù‡Ø§Ø¦ÙŠØ©</title>
    <style>
        /* Ù†ÙØ³ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© - Ø§Ø­ØªÙØ¸ Ø¨Ù‡Ø§ ÙƒÙ…Ø§ Ù‡ÙŠ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        body {
            background: #0a0f1e;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            color: #e2e8f0;
        }
        .phone {
            max-width: 460px;
            width: 100%;
            background: #111827;
            border-radius: 48px;
            padding: 20px 14px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.9);
            border: 1px solid #2d3748;
        }
        .header {
            text-align: center;
            margin-bottom: 15px;
        }
        .header h1 {
            font-size: 28px;
            background: linear-gradient(135deg, #a78bfa, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .badges {
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
            margin: 8px 0 12px;
        }
        .badge {
            background: #1f2a44;
            padding: 4px 14px;
            border-radius: 40px;
            font-size: 11px;
            border: 1px solid #3f4e77;
        }
        .warning-banner {
            background: linear-gradient(135deg, #fbbf24, #f97316);
            padding: 10px;
            border-radius: 20px;
            font-size: 12px;
            margin: 8px 0;
            text-align: center;
            color: #1f1f1f;
            font-weight: 600;
        }
        .visualizer {
            background: #0f172a;
            border-radius: 40px;
            padding: 15px 8px;
            margin-bottom: 16px;
        }
        .wave-row {
            display: flex;
            justify-content: center;
            gap: 4px;
            height: 70px;
        }
        .wave-bar {
            width: 8px;
            height: 20px;
            background: #334155;
            border-radius: 8px;
            transition: height 0.1s, background 0.1s;
        }
        .wave-bar.active {
            background: linear-gradient(to top, #c084fc, #f472b6);
            box-shadow: 0 0 12px #f472b6;
        }
        .freq-labels {
            display: flex;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 11px;
            color: #94a3b8;
            margin-top: 8px;
        }
        .db-meter {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            background: #1e293b;
            padding: 8px 12px;
            border-radius: 30px;
        }
        .db-meter .bar {
            flex: 1;
            height: 8px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
        }
        .db-meter .fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #22c55e, #eab308, #ef4444);
            transition: width 0.1s;
        }
        .db-value {
            font-family: monospace;
            font-size: 12px;
            min-width: 45px;
            text-align: left;
        }
        .advanced-panel {
            background: #1e293b;
            border-radius: 40px;
            padding: 18px;
            margin-bottom: 16px;
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }
        .control-label {
            font-size: 14px;
            min-width: 100px;
        }
        .control-value {
            background: #0f172a;
            padding: 6px 12px;
            border-radius: 30px;
            font-family: monospace;
            font-size: 14px;
            min-width: 80px;
            text-align: center;
        }
        input[type=range] {
            flex: 1;
            height: 6px;
            border-radius: 10px;
            background: #334155;
            -webkit-appearance: none;
            margin: 0 10px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #c084fc;
            border-radius: 50%;
            cursor: pointer;
            transition: 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #e879f9;
            transform: scale(1.2);
        }
        .test-tone-btn {
            background: #2d3a5e;
            border: none;
            color: white;
            padding: 12px;
            border-radius: 40px;
            margin-top: 10px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            transition: 0.2s;
        }
        .test-tone-btn:hover {
            background: #3d4a7e;
            transform: translateY(-2px);
        }
        .status-bar {
            background: #1e293b;
            border-radius: 40px;
            padding: 14px 18px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .led-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .led {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #6b7280;
        }
        .led.listening { background: #22c55e; box-shadow: 0 0 15px #22c55e; animation: pulse-green 1.5s infinite; }
        .led.sending { background: #eab308; box-shadow: 0 0 15px #eab308; animation: pulse-orange 0.8s infinite; }
        .led.muted { background: #ef4444; box-shadow: 0 0 15px #ef4444; }
        @keyframes pulse-green { 0% { opacity:1; } 50% { opacity:0.4; } }
        @keyframes pulse-orange { 0% { transform:scale(1); } 50% { transform:scale(1.3); } }

        .button-grid {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }
        .btn {
            flex: 1 1 40%;
            padding: 16px 10px;
            border: none;
            border-radius: 40px;
            font-weight: 700;
            background: #334155;
            color: #f1f5f9;
            cursor: pointer;
            transition: 0.15s;
            box-shadow: 0 4px 0 #0f172a;
        }
        .btn.primary { background: linear-gradient(145deg, #7c3aed, #c026d3); color: white; box-shadow: 0 4px 0 #5b1e8c; }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #0f172a; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .chat-area {
            background: #1e293b;
            border-radius: 40px;
            padding: 18px;
        }
        .messages {
            background: #0f172a;
            border-radius: 30px;
            padding: 16px;
            height: 220px;
            overflow-y: auto;
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .message {
            max-width: 85%;
            padding: 10px 16px;
            border-radius: 24px;
            font-size: 14px;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .message.sent { background: linear-gradient(145deg, #7c3aed, #a855f7); align-self: flex-end; color: white; }
        .message.received { background: #2d3a5e; align-self: flex-start; }
        .message.system { background: #1e2b44; align-self: center; font-size: 12px; color: #94a3b8; }
        .message img, .message audio, .message video { max-width: 100%; border-radius: 12px; margin-top: 6px; }

        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .input-row input {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: 40px;
            background: #0f172a;
            color: white;
            border: 1px solid #334155;
            transition: 0.2s;
        }
        .input-row input:focus {
            outline: none;
            border-color: #c084fc;
            box-shadow: 0 0 10px rgba(192, 132, 252, 0.3);
        }
        .input-row button {
            width: 70px;
            border-radius: 40px;
            border: none;
            background: linear-gradient(145deg, #7c3aed, #c026d3);
            color: white;
            font-size: 22px;
            cursor: pointer;
            transition: 0.2s;
        }
        .input-row button:hover {
            transform: scale(1.05);
        }

        .action-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .action-btn {
            flex: 1;
            padding: 14px;
            border-radius: 40px;
            border: none;
            background: #28344e;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.2s;
        }
        .action-btn:hover:not(:disabled) {
            background: #354561;
            transform: translateY(-2px);
        }
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            height: 6px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            margin: 12px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #c084fc, #f472b6);
            width: 0%;
            transition: width 0.3s;
        }
        .footer {
            text-align: center;
            margin-top: 16px;
            color: #4b5563;
            font-size: 10px;
        }
        .toggle-advanced {
            background: #1e293b;
            border: none;
            color: #a78bfa;
            padding: 8px;
            width: 100%;
            border-radius: 40px;
            margin-bottom: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }
        .toggle-advanced:hover {
            background: #2d3a5e;
            transform: translateY(-2px);
        }
        .stats-row {
            display: flex;
            justify-content: space-around;
            background: #0f172a;
            border-radius: 30px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 12px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-label {
            color: #94a3b8;
            font-size: 11px;
        }
        .stat-value {
            color: #a78bfa;
            font-weight: bold;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="phone">
        <div class="header">
            <h1>ğŸšï¸ Ù…ÙˆØ¬Ø© Ù…Ø®ØµØµØ©</h1>
            <div class="badges">
                <span class="badge">ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù‡Ø±ØªØ²</span>
                <span class="badge">ØµÙˆØ±</span>
                <span class="badge">ØµÙˆØª</span>
                <span class="badge">ÙÙŠØ¯ÙŠÙˆ</span>
            </div>
            <div class="warning-banner">
                âš ï¸ ÙŠØ­ØªØ§Ø¬ Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ÙˆØ³Ù…Ø§Ø¹Ø§Øª Ø¬ÙŠØ¯Ø© + Ù…ØªØµÙØ­ Ø­Ø¯ÙŠØ«
            </div>
        </div>

        <div class="visualizer">
            <div class="wave-row" id="waveRow"></div>
            <div class="freq-labels" id="freqLabels">
                <span>F0: 19000 Hz</span>
                <span>F1: 20000 Hz</span>
            </div>
            <div class="db-meter">
                <span>ğŸ“Š Ù…Ø³ØªÙˆÙ‰</span>
                <div class="bar"><div class="fill" id="dbFill"></div></div>
                <span class="db-value" id="dbValue">-âˆ dB</span>
            </div>
        </div>

        <div class="stats-row">
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø©</div>
                <div class="stat-value" id="sentCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„Ø©</div>
                <div class="stat-value" id="receivedCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø£Ø®Ø·Ø§Ø¡</div>
                <div class="stat-value" id="errorCount">0</div>
            </div>
        </div>

        <button class="toggle-advanced" id="toggleAdvancedBtn">âš™ï¸ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</button>
        <div id="advancedPanel" style="display: none;">
            <div class="advanced-panel">
                <div class="control-row">
                    <span class="control-label">ØªØ±Ø¯Ø¯ 0 (Hz)</span>
                    <input type="range" id="freq0Slider" min="16000" max="22000" step="100" value="19000">
                    <span class="control-value" id="freq0Value">19000</span>
                </div>
                <div class="control-row">
                    <span class="control-label">ØªØ±Ø¯Ø¯ 1 (Hz)</span>
                    <input type="range" id="freq1Slider" min="16000" max="22000" step="100" value="20000">
                    <span class="control-value" id="freq1Value">20000</span>
                </div>
                <div class="control-row">
                    <span class="control-label">Ù…Ø¯Ø© Ø§Ù„Ø¨Øª (ms)</span>
                    <input type="range" id="bitDurationSlider" min="4" max="20" step="1" value="8">
                    <span class="control-value" id="bitDurationValue">8 ms</span>
                </div>
                <div class="control-row">
                    <span class="control-label">Ø¹ØªØ¨Ø© Ø§Ù„ÙƒØ´Ù</span>
                    <input type="range" id="thresholdSlider" min="0.005" max="0.05" step="0.001" value="0.015">
                    <span class="control-value" id="thresholdValue">0.015</span>
                </div>
                <div class="control-row">
                    <span class="control-label">ØªØ³Ø§Ù…Ø­ Ø§Ù„Ø®Ø·Ø£ (Ø¨Øª)</span>
                    <input type="range" id="toleranceSlider" min="0" max="4" step="1" value="2">
                    <span class="control-value" id="toleranceValue">2</span>
                </div>
                <button class="test-tone-btn" id="testToneBtn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ±Ø¯Ø¯ 0 (Ù†ØºÙ…Ø© Ù…Ø³ØªÙ…Ø±Ø©)</button>
                <button class="test-tone-btn" id="muteToggleBtn">ğŸ”‡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (Ù…ÙØ¹Ù„)</button>
            </div>
        </div>

        <div class="status-bar">
            <span>ğŸ“¡ Ø§Ù„Ø­Ø§Ù„Ø©</span>
            <div class="led-indicator">
                <span id="statusText">Ø®Ø§Ù…Ù„</span>
                <span class="led" id="led"></span>
            </div>
        </div>

        <div class="button-grid">
            <button class="btn primary" id="startBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø§Ø¹</button>
            <button class="btn" id="stopBtn">â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
            <button class="btn" id="testBtn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± Ø±Ø³Ø§Ù„Ø©</button>
            <button class="btn" id="clearBtn">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
        </div>

        <div class="progress-bar" id="progressContainer" style="display: none;">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="chat-area">
            <div class="messages" id="messages">
                <div class="message system">âœ¨ Ø§Ø¶Ø¨Ø· Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª Ø«Ù… Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹.</div>
            </div>
            <div class="input-row">
                <input type="text" id="messageInput" placeholder="Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ©...">
                <button id="sendBtn">â¡ï¸</button>
            </div>
            <div class="action-row">
                <button class="action-btn" id="attachImageBtn">ğŸ“· ØµÙˆØ±Ø©</button>
                <button class="action-btn" id="attachVideoBtn">ğŸ¥ ÙÙŠØ¯ÙŠÙˆ</button>
                <button class="action-btn" id="recordBtn">ğŸ¤ ØªØ³Ø¬ÙŠÙ„</button>
                <button class="action-btn" id="sendAudioBtn" disabled>â³ Ø³Ø¬Ù„ Ø£ÙˆÙ„Ø§Ù‹</button>
            </div>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <input type="file" id="videoInput" accept="video/*" style="display: none;">
        </div>

        <div class="footer">
            âš¡ Ø§Ø¶Ø¨Ø· Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª Ø­Ø³Ø¨ Ø¬Ù‡Ø§Ø²Ùƒ â€¢ Ø§Ø²Ø±Ø§Ø± Ù„Ù„Ù…Ø³ â€¢ Ø¨Ø¯ÙˆÙ† Ø¥Ù†ØªØ±Ù†Øª â€¢ v4.0
        </div>
    </div>

    <script>
        (function() {
            // -------------------- Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ­ÙƒÙ… --------------------
            const toggleAdvancedBtn = document.getElementById('toggleAdvancedBtn');
            const advancedPanel = document.getElementById('advancedPanel');
            const freq0Slider = document.getElementById('freq0Slider');
            const freq1Slider = document.getElementById('freq1Slider');
            const bitDurationSlider = document.getElementById('bitDurationSlider');
            const thresholdSlider = document.getElementById('thresholdSlider');
            const toleranceSlider = document.getElementById('toleranceSlider');
            const freq0Value = document.getElementById('freq0Value');
            const freq1Value = document.getElementById('freq1Value');
            const bitDurationValue = document.getElementById('bitDurationValue');
            const thresholdValue = document.getElementById('thresholdValue');
            const toleranceValue = document.getElementById('toleranceValue');
            const testToneBtn = document.getElementById('testToneBtn');
            const muteToggleBtn = document.getElementById('muteToggleBtn');
            const freqLabels = document.getElementById('freqLabels');
            const dbFill = document.getElementById('dbFill');
            const dbValue = document.getElementById('dbValue');

            // Ø§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª
            let sentCount = 0;
            let receivedCount = 0;
            let errorCount = 0;

            // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø¹ ØªØ­Ù…ÙŠÙ„ Ù…Ù† localStorage
            let CONFIG = {
                FREQ_0: 19000,
                FREQ_1: 20000,
                BIT_DURATION: 0.008,  // 8 ms
                THRESHOLD: 0.015,
                PREAMBLE: [0xAA, 0x55, 0xAA, 0x55, 0xAA],
                SAMPLE_RATE: 48000,
                FFT_SIZE: 8192,
                REPETITION: 2,
                CHUNK_SIZE: 200,
                MAX_RETRY: 5,
                TIMEOUT: 8000,
                AUDIO_MAX_DURATION: 30,
                TOLERANCE: 2,
                MUTE_WHEN_SENDING: true
            };

            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            try {
                const saved = localStorage.getItem('waveConfig');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    Object.assign(CONFIG, parsed);
                    freq0Slider.value = CONFIG.FREQ_0;
                    freq1Slider.value = CONFIG.FREQ_1;
                    bitDurationSlider.value = CONFIG.BIT_DURATION * 1000;
                    thresholdSlider.value = CONFIG.THRESHOLD;
                    toleranceSlider.value = CONFIG.TOLERANCE;
                }
            } catch (e) {}

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø©
            function updateConfigFromSliders() {
                CONFIG.FREQ_0 = parseInt(freq0Slider.value, 10);
                CONFIG.FREQ_1 = parseInt(freq1Slider.value, 10);
                CONFIG.BIT_DURATION = parseInt(bitDurationSlider.value, 10) / 1000;
                CONFIG.THRESHOLD = parseFloat(thresholdSlider.value);
                CONFIG.TOLERANCE = parseInt(toleranceSlider.value, 10);

                freq0Value.textContent = CONFIG.FREQ_0;
                freq1Value.textContent = CONFIG.FREQ_1;
                bitDurationValue.textContent = bitDurationSlider.value + ' ms';
                thresholdValue.textContent = CONFIG.THRESHOLD.toFixed(3);
                toleranceValue.textContent = CONFIG.TOLERANCE;
                freqLabels.innerHTML = `<span>F0: ${CONFIG.FREQ_0} Hz</span> <span>F1: ${CONFIG.FREQ_1} Hz</span>`;

                try {
                    localStorage.setItem('waveConfig', JSON.stringify(CONFIG));
                } catch (e) {}
            }

            freq0Slider.addEventListener('input', updateConfigFromSliders);
            freq1Slider.addEventListener('input', updateConfigFromSliders);
            bitDurationSlider.addEventListener('input', updateConfigFromSliders);
            thresholdSlider.addEventListener('input', updateConfigFromSliders);
            toleranceSlider.addEventListener('input', updateConfigFromSliders);

            toggleAdvancedBtn.addEventListener('click', () => {
                if (advancedPanel.style.display === 'none') {
                    advancedPanel.style.display = 'block';
                    toggleAdvancedBtn.textContent = 'ğŸ”½ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…';
                } else {
                    advancedPanel.style.display = 'none';
                    toggleAdvancedBtn.textContent = 'âš™ï¸ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…';
                }
            });

            let muteEnabled = CONFIG.MUTE_WHEN_SENDING;
            function updateMuteButton() {
                muteToggleBtn.textContent = muteEnabled ? 'ğŸ”‡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (Ù…ÙØ¹Ù„)' : 'ğŸ”Š ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (ØºÙŠØ± Ù…ÙØ¹Ù„)';
            }
            muteToggleBtn.addEventListener('click', () => {
                muteEnabled = !muteEnabled;
                CONFIG.MUTE_WHEN_SENDING = muteEnabled;
                updateMuteButton();
                localStorage.setItem('waveConfig', JSON.stringify(CONFIG));
            });
            updateMuteButton();

            // -------------------- Ø¹Ù†Ø§ØµØ± DOM Ø§Ù„Ø£Ø®Ø±Ù‰ --------------------
            const messagesDiv = document.getElementById('messages');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const testBtn = document.getElementById('testBtn');
            const clearBtn = document.getElementById('clearBtn');
            const attachImageBtn = document.getElementById('attachImageBtn');
            const attachVideoBtn = document.getElementById('attachVideoBtn');
            const recordBtn = document.getElementById('recordBtn');
            const sendAudioBtn = document.getElementById('sendAudioBtn');
            const imageInput = document.getElementById('imageInput');
            const videoInput = document.getElementById('videoInput');
            const statusText = document.getElementById('statusText');
            const led = document.getElementById('led');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const waveRow = document.getElementById('waveRow');
            const sentCountEl = document.getElementById('sentCount');
            const receivedCountEl = document.getElementById('receivedCount');
            const errorCountEl = document.getElementById('errorCount');

            // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø´Ø±Ø·Ø© Ø§Ù„Ù…ÙˆØ¬Ø©
            for (let i = 0; i < 14; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                waveRow.appendChild(bar);
            }
            const waveBars = document.querySelectorAll('.wave-bar');

            // -------------------- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØµÙˆØª ÙˆØ§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ --------------------
            let audioContext = null;
            let isListening = false;
            let isSending = false;
            let sourceNode = null;
            let analyserNode = null;
            let mediaStream = null;
            let mediaStreamSource = null;
            let gainNode = null;

            // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„
            let receivedBits = '';
            let preambleDetected = false;
            let expectedLength = 0;
            let dataBytes = [];
            let bitCount = 0;
            let currentByte = 0;
            let lastBitTime = 0;

            // Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª
            let currentTransferId = null;
            let totalChunks = 0;
            let receivedChunks = new Map();
            let transferType = '';
            let transferMetadata = {};

            // Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ
            let mediaRecorder = null;
            let audioChunks = [];
            let recordedBlob = null;
            let isRecording = false;

            // -------------------- Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© --------------------
            function setStatus(text, ledClass) {
                statusText.innerText = text;
                led.className = 'led ' + ledClass;
            }

            function addMessage(text, type = 'received', isHtml = false) {
                const msg = document.createElement('div');
                msg.classList.add('message', type);
                if (isHtml) {
                    msg.innerHTML = text;
                } else {
                    msg.textContent = text;
                }
                messagesDiv.appendChild(msg);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }

            function updateWaveBars(energy) {
                const activeCount = Math.floor(energy * waveBars.length);
                waveBars.forEach((bar, i) => {
                    if (i < activeCount) {
                        bar.style.height = 30 + energy * 50 + 'px';
                        bar.classList.add('active');
                    } else {
                        bar.style.height = '20px';
                        bar.classList.remove('active');
                    }
                });
            }

            function updateStats() {
                sentCountEl.textContent = sentCount;
                receivedCountEl.textContent = receivedCount;
                errorCountEl.textContent = errorCount;
            }

            function updateDbLevel() {
                if (!analyserNode || !isListening) return;
                const dataArray = new Float32Array(analyserNode.frequencyBinCount);
                analyserNode.getFloatTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / dataArray.length);
                const db = 20 * Math.log10(rms + 1e-10);
                const normalized = Math.min(1, Math.max(0, (db + 100) / 60));
                dbFill.style.width = (normalized * 100) + '%';
                dbValue.textContent = db.toFixed(1) + ' dB';
            }

            async function initAudio() {
                if (audioContext && audioContext.state !== 'closed') return audioContext;
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') await audioContext.resume();
                    return audioContext;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Audio Context:', err);
                    errorCount++;
                    updateStats();
                    throw err;
                }
            }

            // -------------------- Ø§Ø®ØªØ¨Ø§Ø± Ù†ØºÙ…Ø© --------------------
            testToneBtn.addEventListener('click', async () => {
                try {
                    const ctx = await initAudio();
                    const duration = 2;
                    const samples = duration * CONFIG.SAMPLE_RATE;
                    const buffer = ctx.createBuffer(1, samples, CONFIG.SAMPLE_RATE);
                    const channel = buffer.getChannelData(0);
                    const omega = 2 * Math.PI * CONFIG.FREQ_0 / CONFIG.SAMPLE_RATE;
                    for (let i = 0; i < samples; i++) {
                        let windowFactor = 1;
                        if (i < samples * 0.05) windowFactor = 0.5 * (1 - Math.cos(2 * Math.PI * i / (samples * 0.05)));
                        else if (i > samples * 0.95) windowFactor = 0.5 * (1 - Math.cos(2 * Math.PI * (samples - i - 1) / (samples * 0.05)));
                        channel[i] = Math.sin(omega * i) * windowFactor * 0.8;
                    }
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    source.start();
                    addMessage(`ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± ØªØ±Ø¯Ø¯ ${CONFIG.FREQ_0} Hz (Ù„Ù…Ø¯Ø© Ø«Ø§Ù†ÙŠØªÙŠÙ†)`, 'system');
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©', 'system');
                }
            });

            // -------------------- ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ù…ÙˆØ¬Ø§Øª --------------------
            function encodeBytesToFrame(bytes) {
                let frame = [...CONFIG.PREAMBLE];
                frame.push(bytes.length);
                for (let b of bytes) {
                    for (let r = 0; r < CONFIG.REPETITION; r++) frame.push(b);
                }
                let checksum = bytes.length;
                for (let b of bytes) checksum ^= b;
                frame.push(checksum);
                return frame;
            }

            function createWaveform(bytes) {
                try {
                    const bits = [];
                    for (let byte of bytes) {
                        for (let i = 7; i >= 0; i--) bits.push((byte >> i) & 1);
                    }

                    const samplesPerBit = Math.floor(CONFIG.SAMPLE_RATE * CONFIG.BIT_DURATION);
                    const totalSamples = bits.length * samplesPerBit;
                    const audioBuffer = audioContext.createBuffer(1, totalSamples, CONFIG.SAMPLE_RATE);
                    const channel = audioBuffer.getChannelData(0);

                    const hanning = (i, len) => 0.5 * (1 - Math.cos(2 * Math.PI * i / (len - 1)));

                    let idx = 0;
                    for (let bit of bits) {
                        const freq = bit ? CONFIG.FREQ_1 : CONFIG.FREQ_0;
                        const omega = 2 * Math.PI * freq / CONFIG.SAMPLE_RATE;
                        for (let s = 0; s < samplesPerBit; s++) {
                            let windowFactor = 1;
                            if (s < samplesPerBit * 0.1) windowFactor = hanning(s, samplesPerBit * 0.1);
                            else if (s > samplesPerBit * 0.9) windowFactor = hanning(samplesPerBit - s - 1, samplesPerBit * 0.1);
                            channel[idx++] = Math.sin(omega * s) * windowFactor * 0.9;
                        }
                    }
                    return audioBuffer;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¬Ø©:', err);
                    errorCount++;
                    updateStats();
                    throw err;
                }
            }

            async function sendBytes(bytes, desc = 'Ø¨ÙŠØ§Ù†Ø§Øª') {
                if (isSending) {
                    addMessage('âš ï¸ Ù‡Ù†Ø§Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¬Ø§Ø±ÙŠØŒ Ø§Ù†ØªØ¸Ø±', 'system');
                    return;
                }
                isSending = true;
                setStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...', 'sending');

                if (muteEnabled && gainNode) {
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                }

                try {
                    const ctx = await initAudio();
                    const buffer = createWaveform(bytes);
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    source.start();

                    const durationMs = (buffer.length / CONFIG.SAMPLE_RATE) * 1000;
                    const startTime = Date.now();

                    const interval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const prog = Math.min(1, elapsed / durationMs);
                        updateWaveBars(prog);
                        if (prog >= 1) {
                            clearInterval(interval);
                            updateWaveBars(0);
                            isSending = false;
                            setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                            if (muteEnabled && gainNode) {
                                gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                            }
                        }
                    }, 50);

                    source.onended = () => {
                        clearInterval(interval);
                        updateWaveBars(0);
                        isSending = false;
                        setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                        if (muteEnabled && gainNode) {
                            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                        }
                    };
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:', err);
                    isSending = false;
                    errorCount++;
                    updateStats();
                    setStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', '');
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ' + err.message, 'system');
                    if (muteEnabled && gainNode) {
                        gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    }
                }
            }

            async function sendText(text) {
                try {
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(text);
                    const frame = encodeBytesToFrame(bytes);
                    await sendBytes(frame, 'Ù†Øµ');
                    addMessage(text, 'sent');
                    sentCount++;
                    updateStats();
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 'system');
                }
            }

            // -------------------- Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª --------------------
            async function sendFile(file, type) {
                try {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const base64 = e.target.result.split(',')[1];
                            const chunkSize = CONFIG.CHUNK_SIZE;
                            const totalChunks = Math.ceil(base64.length / chunkSize);
                            const transferId = Date.now().toString(36) + Math.random().toString(36).substring(2, 8);

                            addMessage(`ğŸ–¼ï¸ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ ${type}: ${file.name} (${totalChunks} Ø¬Ø²Ø¡)`, 'system');

                            const meta = JSON.stringify({
                                type: type,
                                id: transferId,
                                name: file.name,
                                mime: file.type,
                                size: base64.length,
                                chunks: totalChunks
                            });
                            const metaBytes = new TextEncoder().encode('META:' + meta);
                            await sendBytes(encodeBytesToFrame(metaBytes), 'metadata');

                            progressContainer.style.display = 'block';
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = base64.substr(i * chunkSize, chunkSize);
                                const chunkData = `CHUNK:${transferId}:${i}:${chunk}`;
                                const chunkBytes = new TextEncoder().encode(chunkData);
                                await sendBytes(encodeBytesToFrame(chunkBytes), `Ø¬Ø²Ø¡ ${i+1}/${totalChunks}`);
                                progressFill.style.width = ((i + 1) / totalChunks * 100) + '%';
                                await new Promise(r => setTimeout(r, 300));
                            }
                            progressContainer.style.display = 'none';
                            addMessage(`âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${type}`, 'system');
                            sentCount++;
                            updateStats();
                        } catch (err) {
                            console.error('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù:', err);
                            errorCount++;
                            updateStats();
                            addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù', 'system');
                        }
                    };
                    reader.readAsDataURL(file);
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù:', err);
                    errorCount++;
                    updateStats();
                }
            }

            // -------------------- Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ --------------------
            async function startRecording() {
                if (isRecording) return;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendAudioBtn.disabled = false;
                        addMessage(`ğŸ¤ ØªÙ… ØªØ³Ø¬ÙŠÙ„ ${(recordedBlob.size / 1024).toFixed(1)} ÙƒÙŠÙ„ÙˆØ¨Ø§ÙŠØª`, 'system');
                        stream.getTracks().forEach(t => t.stop());
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = 'â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„';
                    recordBtn.style.background = '#dc2626';
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†:', err);
                    errorCount++;
                    updateStats();
                    alert('âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†: ' + err.message);
                }
            }

            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordBtn.textContent = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„';
                    recordBtn.style.background = '';
                }
            }

            async function sendAudio() {
                if (!recordedBlob) return;
                try {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const base64 = e.target.result.split(',')[1];
                            const chunkSize = CONFIG.CHUNK_SIZE;
                            const totalChunks = Math.ceil(base64.length / chunkSize);
                            const transferId = Date.now().toString(36) + Math.random().toString(36).substring(2, 8);

                            addMessage(`ğŸµ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØµÙˆØªÙŠØ© (${totalChunks} Ø¬Ø²Ø¡)`, 'system');

                            const meta = JSON.stringify({
                                type: 'audio',
                                id: transferId,
                                duration: recordedBlob.size / 16000 / 2,
                                chunks: totalChunks
                            });
                            const metaBytes = new TextEncoder().encode('META:' + meta);
                            await sendBytes(encodeBytesToFrame(metaBytes), 'audio meta');

                            progressContainer.style.display = 'block';
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = base64.substr(i * chunkSize, chunkSize);
                                const chunkData = `CHUNK:${transferId}:${i}:${chunk}`;
                                const chunkBytes = new TextEncoder().encode(chunkData);
                                await sendBytes(encodeBytesToFrame(chunkBytes), `audio part ${i+1}`);
                                progressFill.style.width = ((i + 1) / totalChunks * 100) + '%';
                                await new Promise(r => setTimeout(r, 300));
                            }
                            progressContainer.style.display = 'none';
                            addMessage('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØµÙˆØªÙŠØ©', 'system');
                            recordedBlob = null;
                            sendAudioBtn.disabled = true;
                            sentCount++;
                            updateStats();
                        } catch (err) {
                            console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª:', err);
                            errorCount++;
                            updateStats();
                            addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª', 'system');
                        }
                    };
                    reader.readAsDataURL(recordedBlob);
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØª:', err);
                    errorCount++;
                    updateStats();
                }
            }

            // -------------------- Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ ÙˆØ§Ù„ÙÙƒ ØªØ´ÙÙŠØ± (Ù…Ø­Ø¯Ø«) --------------------
            async function startListening() {
                if (isListening) return;
                try {
                    const ctx = await initAudio();
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false } });
                    mediaStreamSource = ctx.createMediaStreamSource(mediaStream);
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ analyser Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª
                    analyserNode = ctx.createAnalyser();
                    analyserNode.fftSize = CONFIG.FFT_SIZE;
                    analyserNode.smoothingTimeConstant = 0.8;
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ gain node Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ ÙƒØªÙ… Ø§Ù„ØµÙˆØª
                    gainNode = ctx.createGain();
                    gainNode.gain.value = 1;
                    
                    mediaStreamSource.connect(analyserNode);
                    analyserNode.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    isListening = true;
                    receivedBits = '';
                    preambleDetected = false;
                    expectedLength = 0;
                    dataBytes = [];
                    bitCount = 0;
                    currentByte = 0;
                    
                    setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                    addMessage('ğŸ§ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹...', 'system');
                    
                    // Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
                    const processAudio = () => {
                        if (!isListening) return;
                        
                        updateDbLevel();
                        detectBitsFromFrequency();
                        updateWaveBars(0.3 + Math.random() * 0.3);
                        
                        requestAnimationFrame(processAudio);
                    };
                    processAudio();
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹:', err);
                    errorCount++;
                    updateStats();
                    alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†:\n' + err.message);
                    setStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', '');
                }
            }

            function stopListening() {
                if (!isListening) return;
                isListening = false;
                setStatus('Ù…ØªÙˆÙ‚Ù', '');
                
                if (mediaStreamSource) {
                    mediaStreamSource.disconnect();
                    mediaStream.getTracks().forEach(t => t.stop());
                }
                
                addMessage('â¹ï¸ ØªÙˆÙ‚Ù Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'system');
            }

            // ÙƒØ´Ù Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª Ù…Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ (FFT)
            function detectBitsFromFrequency() {
                if (!analyserNode) return;
                
                const freqData = new Uint8Array(analyserNode.frequencyBinCount);
                analyserNode.getByteFrequencyData(freqData);
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·Ø§Ù‚Ø© Ø¹Ù†Ø¯ Ø§Ù„ØªØ±Ø¯Ø¯ 0 ÙˆØ§Ù„ØªØ±Ø¯Ø¯ 1
                const bin0 = Math.floor(CONFIG.FREQ_0 * CONFIG.FFT_SIZE / CONFIG.SAMPLE_RATE);
                const bin1 = Math.floor(CONFIG.FREQ_1 * CONFIG.FFT_SIZE / CONFIG.SAMPLE_RATE);
                
                // Ø£Ø®Ø° Ù…ØªÙˆØ³Ø· Ø¹Ø¯Ø© bins Ø­ÙˆÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
                const getBinEnergy = (bin) => {
                    let sum = 0;
                    for (let i = Math.max(0, bin - 2); i <= Math.min(freqData.length - 1, bin + 2); i++) {
                        sum += freqData[i];
                    }
                    return sum / 5;
                };
                
                const energy0 = getBinEnergy(bin0);
                const energy1 = getBinEnergy(bin1);
                
                // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¨Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø£ÙŠÙ‡Ù…Ø§ Ø£Ù‚ÙˆÙ‰
                const bit = energy1 > energy0 ? 1 : 0;
                
                // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ØªØ§Øª
                const now = Date.now();
                if (now - lastBitTime > CONFIG.BIT_DURATION * 1000 * 0.7) {
                    receivedBits += bit;
                    lastBitTime = now;
                    
                    // Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙƒ ØªØ´ÙÙŠØ± ÙƒÙ„ 8 Ø¨ØªØ§Øª
                    if (receivedBits.length >= 8) {
                        decodeBits();
                    }
                }
            }

            // ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ø¨ØªØ§Øª Ø¥Ù„Ù‰ Ø¨Ø§ÙŠØªØ§Øª
            function decodeBits() {
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Preamble
                if (!preambleDetected) {
                    const preambleBinary = CONFIG.PREAMBLE.map(b => b.toString(2).padStart(8, '0')).join('');
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† preamble Ø¨Ù…Ø³Ø§ÙØ© Ù‡Ø§Ù…ÙŠÙ†Øº
                    if (receivedBits.length >= preambleBinary.length) {
                        const candidate = receivedBits.substring(0, preambleBinary.length);
                        const hammingDistance = countHammingDistance(candidate, preambleBinary);
                        
                        if (hammingDistance <= CONFIG.TOLERANCE) {
                            preambleDetected = true;
                            receivedBits = receivedBits.substring(preambleBinary.length);
                            bitCount = 0;
                            dataBytes = [];
                            addMessage('ğŸ“¡ ØªÙ… ÙƒØ´Ù Ø§Ù„Ù€ Preamble', 'system');
                            return;
                        }
                        
                        // Ù†Ø²Ø¹ Ø£ÙˆÙ„ Ø¨Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                        receivedBits = receivedBits.substring(1);
                    }
                }
                
                // Ø¨Ø¹Ø¯ ÙƒØ´Ù preambleØŒ Ù†Ù‚Ø±Ø£ Ø­Ø¬Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                if (preambleDetected && expectedLength === 0 && receivedBits.length >= 8) {
                    const lengthBits = receivedBits.substring(0, 8);
                    expectedLength = parseInt(lengthBits, 2);
                    receivedBits = receivedBits.substring(8);
                    bitCount = 0;
                    dataBytes = [];
                    addMessage(`ğŸ“¦ Ø­Ø¬Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${expectedLength} Ø¨Ø§ÙŠØª`, 'system');
                    return;
                }
                
                // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                if (preambleDetected && expectedLength > 0) {
                    while (receivedBits.length >= 8 && dataBytes.length < expectedLength * CONFIG.REPETITION) {
                        const byteBits = receivedBits.substring(0, 8);
                        receivedBits = receivedBits.substring(8);
                        const byte = parseInt(byteBits, 2);
                        dataBytes.push(byte);
                    }
                    
                    // Ø¨Ø¹Ø¯ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ±Ø¯ÙŠØ¯Ø§ØªØŒ Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ©
                    if (dataBytes.length >= expectedLength * CONFIG.REPETITION) {
                        const finalBytes = [];
                        for (let i = 0; i < expectedLength; i++) {
                            const repeats = [];
                            for (let r = 0; r < CONFIG.REPETITION; r++) {
                                repeats.push(dataBytes[i * CONFIG.REPETITION + r]);
                            }
                            // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ÙƒØ«Ø± ØªÙƒØ±Ø§Ø±Ø§Ù‹ (majority voting)
                            finalBytes.push(majorityVote(repeats));
                        }
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Checksum
                        if (dataBytes.length > expectedLength * CONFIG.REPETITION) {
                            const checksumBits = receivedBits.substring(0, 8);
                            const receivedChecksum = parseInt(checksumBits, 2);
                            let calculatedChecksum = expectedLength;
                            for (let b of finalBytes) calculatedChecksum ^= b;
                            
                            if (receivedChecksum === calculatedChecksum) {
                                processReceivedData(finalBytes);
                            } else {
                                errorCount++;
                                updateStats();
                                addMessage('âŒ Ø®Ø·Ø£ Checksum', 'system');
                            }
                        }
                        
                        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù„Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
                        preambleDetected = false;
                        expectedLength = 0;
                        dataBytes = [];
                        receivedBits = '';
                    }
                }
            }

            function countHammingDistance(str1, str2) {
                let distance = 0;
                for (let i = 0; i < str1.length; i++) {
                    if (str1[i] !== str2[i]) distance++;
                }
                return distance;
            }

            function majorityVote(arr) {
                const counts = {};
                for (let val of arr) {
                    counts[val] = (counts[val] || 0) + 1;
                }
                return parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));
            }

            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„Ø©
            function processReceivedData(bytes) {
                try {
                    const text = new TextDecoder().decode(new Uint8Array(bytes));
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    if (text.startsWith('META:')) {
                        const meta = JSON.parse(text.substring(5));
                        transferType = meta.type;
                        transferMetadata = meta;
                        receivedChunks.clear();
                        addMessage(`ğŸ“¥ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù…Ù„Ù: ${meta.name} (${meta.chunks} Ø£Ø¬Ø²Ø§Ø¡)`, 'system');
                    } else if (text.startsWith('CHUNK:')) {
                        const parts = text.split(':');
                        const id = parts[1];
                        const index = parseInt(parts[2]);
                        const data = parts.slice(3).join(':');
                        receivedChunks.set(index, data);
                        
                        const progress = (receivedChunks.size / transferMetadata.chunks) * 100;
                        progressFill.style.width = progress + '%';
                        
                        if (receivedChunks.size === transferMetadata.chunks) {
                            assembleFile();
                        }
                    } else {
                        // Ù†Øµ Ø¹Ø§Ø¯ÙŠ
                        if (text.trim() !== '') {
                            addMessage(text, 'received');
                            receivedCount++;
                            updateStats();
                        } else {
                            addMessage('âš ï¸ Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ© ÙØ§Ø±ØºØ©', 'system');
                        }
                    }
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±', 'system');
                }
            }

            function assembleFile() {
                try {
                    let fullBase64 = '';
                    for (let i = 0; i < transferMetadata.chunks; i++) {
                        fullBase64 += receivedChunks.get(i);
                    }
                    
                    const binaryString = atob(fullBase64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const blob = new Blob([bytes], { type: transferMetadata.mime });
                    const url = URL.createObjectURL(blob);
                    
                    const container = document.createElement('div');
                    container.classList.add('message', 'received');
                    
                    if (transferMetadata.type === 'image' || transferMetadata.type === 'ØµÙˆØ±Ø©') {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.maxWidth = '200px';
                        img.style.borderRadius = '12px';
                        container.appendChild(img);
                    } else if (transferMetadata.type === 'video' || transferMetadata.type === 'ÙÙŠØ¯ÙŠÙˆ') {
                        const video = document.createElement('video');
                        video.src = url;
                        video.controls = true;
                        video.style.maxWidth = '100%';
                        video.style.borderRadius = '12px';
                        container.appendChild(video);
                    } else if (transferMetadata.type === 'audio') {
                        const audio = document.createElement('audio');
                        audio.src = url;
                        audio.controls = true;
                        audio.style.width = '100%';
                        container.appendChild(audio);
                    }
                    
                    messagesDiv.appendChild(container);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    
                    receivedCount++;
                    updateStats();
                    addMessage(`âœ… ØªÙ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ ${transferMetadata.name}`, 'system');
                    
                    progressContainer.style.display = 'none';
                    currentTransferId = null;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„Ù:', err);
                    errorCount++;
                    updateStats();
                }
            }

            // -------------------- Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø± --------------------
            startBtn.addEventListener('click', startListening);
            stopBtn.addEventListener('click', stopListening);
            
            sendBtn.addEventListener('click', () => {
                const text = messageInput.value.trim();
                if (text) {
                    sendText(text);
                    messageInput.value = '';
                }
            });

            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const text = messageInput.value.trim();
                    if (text) {
                        sendText(text);
                        messageInput.value = '';
                    }
                }
            });

            testBtn.addEventListener('click', () => {
                sendText('ğŸ¤ Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªØ¨Ø§Ø±: Ù…Ø±Ø­Ø¨Ø§Ù‹! Ù‡Ù„ ØªØ³Ù…Ø¹Ù†ÙŠØŸ');
            });

            clearBtn.addEventListener('click', () => {
                messagesDiv.innerHTML = '<div class="message system">âœ¨ ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„.</div>';
                sentCount = 0;
                receivedCount = 0;
                errorCount = 0;
                updateStats();
            });

            attachImageBtn.addEventListener('click', () => imageInput.click());
            attachVideoBtn.addEventListener('click', () => videoInput.click());
            recordBtn.addEventListener('click', () => isRecording ? stopRecording() : startRecording());
            sendAudioBtn.addEventListener('click', sendAudio);

            imageInput.addEventListener('change', (e) => {
                if (e.target.files[0]) sendFile(e.target.files[0], 'ØµÙˆØ±Ø©');
            });

            videoInput.addEventListener('change', (e) => {
                if (e.target.files[0]) sendFile(e.target.files[0], 'ÙÙŠØ¯ÙŠÙˆ');
            });

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ… Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
            updateConfigFromSliders();

            // Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
            // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ø¨Ø¯Ø¡ ÙŠØ¯ÙˆÙŠØ§Ù‹
        })();
    </script>
</body>
</html>