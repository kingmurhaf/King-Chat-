<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù…ÙˆØ¬Ø© Ù…Ø®ØµØµØ© - Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø³Ù…ÙˆØ¹</title>
    <style>
        /* Ù†ÙØ³ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù…Ø¹ Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø© */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        body {
            background: #0a0f1e;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            color: #e2e8f0;
        }
        .phone {
            max-width: 460px;
            width: 100%;
            background: #111827;
            border-radius: 48px;
            padding: 20px 14px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.9);
            border: 1px solid #2d3748;
        }
        .header {
            text-align: center;
            margin-bottom: 15px;
        }
        .header h1 {
            font-size: 28px;
            background: linear-gradient(135deg, #a78bfa, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .badges {
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
            margin: 8px 0 12px;
        }
        .badge {
            background: #1f2a44;
            padding: 4px 14px;
            border-radius: 40px;
            font-size: 11px;
            border: 1px solid #3f4e77;
        }
        .warning-banner {
            background: linear-gradient(135deg, #fbbf24, #f97316);
            padding: 10px;
            border-radius: 20px;
            font-size: 12px;
            margin: 8px 0;
            text-align: center;
            color: #1f1f1f;
            font-weight: 600;
        }
        .visualizer {
            background: #0f172a;
            border-radius: 40px;
            padding: 15px 8px;
            margin-bottom: 16px;
        }
        .wave-row {
            display: flex;
            justify-content: center;
            gap: 4px;
            height: 70px;
        }
        .wave-bar {
            width: 8px;
            height: 20px;
            background: #334155;
            border-radius: 8px;
            transition: height 0.1s, background 0.1s;
        }
        .wave-bar.active {
            background: linear-gradient(to top, #c084fc, #f472b6);
            box-shadow: 0 0 12px #f472b6;
        }
        .freq-labels {
            display: flex;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 11px;
            color: #94a3b8;
            margin-top: 8px;
        }
        .db-meter {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            background: #1e293b;
            padding: 8px 12px;
            border-radius: 30px;
        }
        .db-meter .bar {
            flex: 1;
            height: 8px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
        }
        .db-meter .fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #22c55e, #eab308, #ef4444);
            transition: width 0.1s;
        }
        .db-value {
            font-family: monospace;
            font-size: 12px;
            min-width: 45px;
            text-align: left;
        }
        .advanced-panel {
            background: #1e293b;
            border-radius: 40px;
            padding: 18px;
            margin-bottom: 16px;
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }
        .control-label {
            font-size: 14px;
            min-width: 100px;
        }
        .control-value {
            background: #0f172a;
            padding: 6px 12px;
            border-radius: 30px;
            font-family: monospace;
            font-size: 14px;
            min-width: 80px;
            text-align: center;
        }
        input[type=range] {
            flex: 1;
            height: 6px;
            border-radius: 10px;
            background: #334155;
            -webkit-appearance: none;
            margin: 0 10px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #c084fc;
            border-radius: 50%;
            cursor: pointer;
            transition: 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #e879f9;
            transform: scale(1.2);
        }
        .test-tone-btn {
            background: #2d3a5e;
            border: none;
            color: white;
            padding: 12px;
            border-radius: 40px;
            margin-top: 10px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            transition: 0.2s;
        }
        .test-tone-btn:hover {
            background: #3d4a7e;
            transform: translateY(-2px);
        }
        .status-bar {
            background: #1e293b;
            border-radius: 40px;
            padding: 14px 18px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .led-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .led {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #6b7280;
        }
        .led.listening { background: #22c55e; box-shadow: 0 0 15px #22c55e; animation: pulse-green 1.5s infinite; }
        .led.sending { background: #eab308; box-shadow: 0 0 15px #eab308; animation: pulse-orange 0.8s infinite; }
        .led.muted { background: #ef4444; box-shadow: 0 0 15px #ef4444; }
        .led.recording { background: #ef4444; box-shadow: 0 0 15px #ef4444; animation: pulse-red 1s infinite; }
        @keyframes pulse-green { 0% { opacity:1; } 50% { opacity:0.4; } }
        @keyframes pulse-orange { 0% { transform:scale(1); } 50% { transform:scale(1.3); } }
        @keyframes pulse-red { 0% { opacity:1; } 50% { opacity:0.4; } }

        .button-grid {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }
        .btn {
            flex: 1 1 40%;
            padding: 16px 10px;
            border: none;
            border-radius: 40px;
            font-weight: 700;
            background: #334155;
            color: #f1f5f9;
            cursor: pointer;
            transition: 0.15s;
            box-shadow: 0 4px 0 #0f172a;
        }
        .btn.primary { background: linear-gradient(145deg, #7c3aed, #c026d3); color: white; box-shadow: 0 4px 0 #5b1e8c; }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #0f172a; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .chat-area {
            background: #1e293b;
            border-radius: 40px;
            padding: 18px;
        }
        .messages {
            background: #0f172a;
            border-radius: 30px;
            padding: 16px;
            height: 220px;
            overflow-y: auto;
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .message {
            max-width: 85%;
            padding: 10px 16px;
            border-radius: 24px;
            font-size: 14px;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .message.sent { background: linear-gradient(145deg, #7c3aed, #a855f7); align-self: flex-end; color: white; }
        .message.received { background: #2d3a5e; align-self: flex-start; }
        .message.system { background: #1e2b44; align-self: center; font-size: 12px; color: #94a3b8; }
        .message img, .message audio, .message video { max-width: 100%; border-radius: 12px; margin-top: 6px; }

        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .input-row input {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: 40px;
            background: #0f172a;
            color: white;
            border: 1px solid #334155;
            transition: 0.2s;
        }
        .input-row input:focus {
            outline: none;
            border-color: #c084fc;
            box-shadow: 0 0 10px rgba(192, 132, 252, 0.3);
        }
        .input-row button {
            width: 70px;
            border-radius: 40px;
            border: none;
            background: linear-gradient(145deg, #7c3aed, #c026d3);
            color: white;
            font-size: 22px;
            cursor: pointer;
            transition: 0.2s;
        }
        .input-row button:hover {
            transform: scale(1.05);
        }

        .action-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .action-btn {
            flex: 1;
            padding: 14px;
            border-radius: 40px;
            border: none;
            background: #28344e;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.2s;
        }
        .action-btn:hover:not(:disabled) {
            background: #354561;
            transform: translateY(-2px);
        }
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            height: 6px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            margin: 12px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #c084fc, #f472b6);
            width: 0%;
            transition: width 0.3s;
        }
        .footer {
            text-align: center;
            margin-top: 16px;
            color: #4b5563;
            font-size: 10px;
        }
        .toggle-advanced {
            background: #1e293b;
            border: none;
            color: #a78bfa;
            padding: 8px;
            width: 100%;
            border-radius: 40px;
            margin-bottom: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }
        .toggle-advanced:hover {
            background: #2d3a5e;
            transform: translateY(-2px);
        }
        .stats-row {
            display: flex;
            justify-content: space-around;
            background: #0f172a;
            border-radius: 30px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 12px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-label {
            color: #94a3b8;
            font-size: 11px;
        }
        .stat-value {
            color: #a78bfa;
            font-weight: bold;
            font-family: monospace;
        }
        .library-section {
            background: #1e293b;
            border-radius: 40px;
            padding: 12px;
            margin: 16px 0;
        }
        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .library-title {
            font-weight: bold;
            color: #a78bfa;
        }
        .library-list {
            max-height: 150px;
            overflow-y: auto;
            background: #0f172a;
            border-radius: 30px;
            padding: 8px;
        }
        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #334155;
            font-size: 12px;
        }
        .library-item:last-child {
            border-bottom: none;
        }
        .library-item button {
            background: #7c3aed;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 11px;
            cursor: pointer;
            margin-right: 4px;
        }
        .library-item button.delete {
            background: #dc2626;
        }
        .record-row {
            display: flex;
            gap: 8px;
            margin: 12px 0;
            flex-wrap: wrap;
        }
        .record-btn {
            flex: 1;
            padding: 12px;
            border-radius: 40px;
            border: none;
            background: #7c3aed;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }
        .record-btn.stop {
            background: #dc2626;
        }
        .record-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .file-input-label {
            flex: 1;
            padding: 12px;
            border-radius: 40px;
            background: #2d3a5e;
            color: white;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
        }
        .file-input-label:hover {
            background: #3d4a7e;
        }
        #audioFileInput {
            display: none;
        }
        .test-row {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }
        .test-row button {
            flex: 1;
            padding: 12px;
            border-radius: 40px;
            border: none;
            background: #2d3a5e;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        .current-bit {
            background: #1e293b;
            padding: 8px;
            border-radius: 20px;
            text-align: center;
            margin: 8px 0;
            font-size: 14px;
        }
        .mode-switch {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }
        .mode-switch button {
            flex: 1;
            padding: 8px;
            border-radius: 30px;
            border: none;
            background: #334155;
            color: white;
            cursor: pointer;
        }
        .mode-switch button.active {
            background: #7c3aed;
            box-shadow: 0 0 10px #a78bfa;
        }
    </style>
</head>
<body>
    <div class="phone">
        <div class="header">
            <h1>ğŸšï¸ Ù…ÙˆØ¬Ø© Ù…Ø®ØµØµØ©</h1>
            <div class="badges">
                <span class="badge">ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù‡Ø±ØªØ²</span>
                <span class="badge">ØµÙˆØ±</span>
                <span class="badge">ØµÙˆØª</span>
                <span class="badge">ÙÙŠØ¯ÙŠÙˆ</span>
                <span class="badge">ØªØ³Ø¬ÙŠÙ„</span>
            </div>
            <div class="warning-banner">
                âš ï¸ Ø¥Ø°Ø§ Ù„Ù… ØªØ³Ù…Ø¹ ÙØ±Ù‚Ø§Ù‹ØŒ Ø¬Ø±Ø¨ ÙˆØ¶Ø¹ "Ù…Ø³Ù…ÙˆØ¹" Ø¨Ø§Ù„Ø£Ø³ÙÙ„.
            </div>
        </div>

        <!-- Ù…Ø¨Ø¯Ù„ ÙˆØ¶Ø¹ Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª (ÙÙˆÙ‚ ØµÙˆØªÙŠ / Ù…Ø³Ù…ÙˆØ¹) -->
        <div class="mode-switch">
            <button id="modeUltrasonic" class="active">ğŸ”Š ÙÙˆÙ‚ ØµÙˆØªÙŠ (19k/20k Hz)</button>
            <button id="modeAudible">ğŸ‘‚ Ù…Ø³Ù…ÙˆØ¹ (500/1000 Hz)</button>
        </div>

        <div class="visualizer">
            <div class="wave-row" id="waveRow"></div>
            <div class="freq-labels" id="freqLabels">
                <span>F0: 19000 Hz</span>
                <span>F1: 20000 Hz</span>
            </div>
            <div class="db-meter">
                <span>ğŸ“Š Ù…Ø³ØªÙˆÙ‰</span>
                <div class="bar"><div class="fill" id="dbFill"></div></div>
                <span class="db-value" id="dbValue">-âˆ dB</span>
            </div>
        </div>

        <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ -->
        <div class="current-bit" id="currentBitDisplay">â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -</div>

        <div class="stats-row">
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø©</div>
                <div class="stat-value" id="sentCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„Ø©</div>
                <div class="stat-value" id="receivedCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ø§Ù„Ø£Ø®Ø·Ø§Ø¡</div>
                <div class="stat-value" id="errorCount">0</div>
            </div>
        </div>

        <button class="toggle-advanced" id="toggleAdvancedBtn">âš™ï¸ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</button>
        <div id="advancedPanel" style="display: none;">
            <div class="advanced-panel">
                <div class="control-row">
                    <span class="control-label">ØªØ±Ø¯Ø¯ 0 (Hz)</span>
                    <input type="range" id="freq0Slider" min="200" max="22000" step="100" value="19000">
                    <span class="control-value" id="freq0Value">19000</span>
                </div>
                <div class="control-row">
                    <span class="control-label">ØªØ±Ø¯Ø¯ 1 (Hz)</span>
                    <input type="range" id="freq1Slider" min="200" max="22000" step="100" value="20000">
                    <span class="control-value" id="freq1Value">20000</span>
                </div>
                <div class="control-row">
                    <span class="control-label">Ù…Ø¯Ø© Ø§Ù„Ø¨Øª (ms)</span>
                    <input type="range" id="bitDurationSlider" min="4" max="100" step="1" value="8">
                    <span class="control-value" id="bitDurationValue">8 ms</span>
                </div>
                <div class="control-row">
                    <span class="control-label">Ø¹ØªØ¨Ø© Ø§Ù„ÙƒØ´Ù</span>
                    <input type="range" id="thresholdSlider" min="0.005" max="0.05" step="0.001" value="0.015">
                    <span class="control-value" id="thresholdValue">0.015</span>
                </div>
                <div class="control-row">
                    <span class="control-label">ØªØ³Ø§Ù…Ø­ Ø§Ù„Ø®Ø·Ø£ (Ø¨Øª)</span>
                    <input type="range" id="toleranceSlider" min="0" max="4" step="1" value="2">
                    <span class="control-value" id="toleranceValue">2</span>
                </div>
                <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù†ÙØµÙ„Ø© Ù„ÙƒÙ„ ØªØ±Ø¯Ø¯ -->
                <div class="test-row">
                    <button class="test-tone-btn" id="testFreq0Btn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± ØªØ±Ø¯Ø¯ 0</button>
                    <button class="test-tone-btn" id="testFreq1Btn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± ØªØ±Ø¯Ø¯ 1</button>
                </div>
                <button class="test-tone-btn" id="muteToggleBtn">ğŸ”‡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (Ù…ÙØ¹Ù„)</button>
            </div>
        </div>

        <div class="status-bar">
            <span>ğŸ“¡ Ø§Ù„Ø­Ø§Ù„Ø©</span>
            <div class="led-indicator">
                <span id="statusText">Ø®Ø§Ù…Ù„</span>
                <span class="led" id="led"></span>
            </div>
        </div>

        <div class="button-grid">
            <button class="btn primary" id="startBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø§Ø¹</button>
            <button class="btn" id="stopBtn">â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
            <button class="btn" id="testBtn">ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± Ø±Ø³Ø§Ù„Ø©</button>
            <button class="btn" id="clearBtn">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
        </div>

        <div class="record-row">
            <button class="record-btn" id="startRecordBtn">âºï¸ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
            <button class="record-btn stop" id="stopRecordBtn" disabled>â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
        </div>
        <div class="record-row">
            <label for="audioFileInput" class="file-input-label">ğŸ“‚ Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØªÙŠ</label>
            <button class="record-btn" id="decodeFileBtn" disabled>ğŸ”“ ÙÙƒ Ø§Ù„Ù…Ù„Ù</button>
        </div>
        <input type="file" id="audioFileInput" accept="audio/*">

        <div class="library-section">
            <div class="library-header">
                <span class="library-title">ğŸ“š Ø§Ù„Ù…ÙƒØªØ¨Ø©</span>
                <button class="record-btn" id="refreshLibraryBtn" style="padding:4px 8px; font-size:11px;">ğŸ”„ ØªØ­Ø¯ÙŠØ«</button>
            </div>
            <div class="library-list" id="libraryList">
                <div class="message system">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>
            </div>
        </div>

        <div class="progress-bar" id="progressContainer" style="display: none;">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="chat-area">
            <div class="messages" id="messages">
                <div class="message system">âœ¨ Ø§Ø¶Ø¨Ø· Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª Ø«Ù… Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø£Ùˆ Ø³Ø¬Ù„ Ø±Ø³Ø§Ù„Ø©.</div>
            </div>
            <div class="input-row">
                <input type="text" id="messageInput" placeholder="Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ©...">
                <button id="sendBtn">â¡ï¸</button>
            </div>
            <div class="action-row">
                <button class="action-btn" id="attachImageBtn">ğŸ“· ØµÙˆØ±Ø©</button>
                <button class="action-btn" id="attachVideoBtn">ğŸ¥ ÙÙŠØ¯ÙŠÙˆ</button>
                <button class="action-btn" id="recordBtn">ğŸ¤ ØªØ³Ø¬ÙŠÙ„</button>
                <button class="action-btn" id="sendAudioBtn" disabled>â³ Ø³Ø¬Ù„ Ø£ÙˆÙ„Ø§Ù‹</button>
            </div>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <input type="file" id="videoInput" accept="video/*" style="display: none;">
        </div>

        <div class="footer">
            âš¡ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Goertzel â€¢ ØªØ®Ø²ÙŠÙ† Ù…Ø­Ù„ÙŠ â€¢ v8.0 (Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø³Ù…ÙˆØ¹)
        </div>
    </div>

    <script>
        (function() {
            // ==================== Ø§Ù„Ø¹Ù†Ø§ØµØ± ====================
            const toggleAdvancedBtn = document.getElementById('toggleAdvancedBtn');
            const advancedPanel = document.getElementById('advancedPanel');
            const freq0Slider = document.getElementById('freq0Slider');
            const freq1Slider = document.getElementById('freq1Slider');
            const bitDurationSlider = document.getElementById('bitDurationSlider');
            const thresholdSlider = document.getElementById('thresholdSlider');
            const toleranceSlider = document.getElementById('toleranceSlider');
            const freq0Value = document.getElementById('freq0Value');
            const freq1Value = document.getElementById('freq1Value');
            const bitDurationValue = document.getElementById('bitDurationValue');
            const thresholdValue = document.getElementById('thresholdValue');
            const toleranceValue = document.getElementById('toleranceValue');
            const testFreq0Btn = document.getElementById('testFreq0Btn');
            const testFreq1Btn = document.getElementById('testFreq1Btn');
            const muteToggleBtn = document.getElementById('muteToggleBtn');
            const freqLabels = document.getElementById('freqLabels');
            const dbFill = document.getElementById('dbFill');
            const dbValue = document.getElementById('dbValue');
            const sentCountEl = document.getElementById('sentCount');
            const receivedCountEl = document.getElementById('receivedCount');
            const errorCountEl = document.getElementById('errorCount');
            const messagesDiv = document.getElementById('messages');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const testBtn = document.getElementById('testBtn');
            const clearBtn = document.getElementById('clearBtn');
            const attachImageBtn = document.getElementById('attachImageBtn');
            const attachVideoBtn = document.getElementById('attachVideoBtn');
            const recordBtn = document.getElementById('recordBtn');
            const sendAudioBtn = document.getElementById('sendAudioBtn');
            const imageInput = document.getElementById('imageInput');
            const videoInput = document.getElementById('videoInput');
            const statusText = document.getElementById('statusText');
            const led = document.getElementById('led');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const waveRow = document.getElementById('waveRow');
            const startRecordBtn = document.getElementById('startRecordBtn');
            const stopRecordBtn = document.getElementById('stopRecordBtn');
            const audioFileInput = document.getElementById('audioFileInput');
            const decodeFileBtn = document.getElementById('decodeFileBtn');
            const libraryList = document.getElementById('libraryList');
            const refreshLibraryBtn = document.getElementById('refreshLibraryBtn');
            const currentBitDisplay = document.getElementById('currentBitDisplay');
            const modeUltrasonic = document.getElementById('modeUltrasonic');
            const modeAudible = document.getElementById('modeAudible');

            // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø´Ø±Ø·Ø© Ø§Ù„Ù…ÙˆØ¬Ø©
            for (let i = 0; i < 14; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                waveRow.appendChild(bar);
            }
            const waveBars = document.querySelectorAll('.wave-bar');

            // ==================== Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ====================
            let CONFIG = {
                FREQ_0: 19000,
                FREQ_1: 20000,
                BIT_DURATION: 0.008,          // Ø«Ø§Ù†ÙŠØ©
                THRESHOLD: 0.015,
                PREAMBLE: [0xAA, 0x55, 0xAA, 0x55, 0xAA],
                SAMPLE_RATE: 48000,
                FFT_SIZE: 4096,                 // Ø£ØµØºØ± Ù„Ù„Ø³Ø±Ø¹Ø©
                REPETITION: 2,
                CHUNK_SIZE: 200,
                MAX_RETRY: 3,
                TIMEOUT: 5000,
                TOLERANCE: 2,
                MUTE_WHEN_SENDING: true,
                get SAMPLES_PER_BIT() { return Math.floor(this.SAMPLE_RATE * this.BIT_DURATION); }
            };

            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            try {
                const saved = localStorage.getItem('waveConfig');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    Object.assign(CONFIG, parsed);
                    freq0Slider.value = CONFIG.FREQ_0;
                    freq1Slider.value = CONFIG.FREQ_1;
                    bitDurationSlider.value = CONFIG.BIT_DURATION * 1000;
                    thresholdSlider.value = CONFIG.THRESHOLD;
                    toleranceSlider.value = CONFIG.TOLERANCE;
                }
            } catch (e) {}

            function updateConfigFromSliders() {
                CONFIG.FREQ_0 = parseInt(freq0Slider.value, 10);
                CONFIG.FREQ_1 = parseInt(freq1Slider.value, 10);
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ±Ø¯Ø¯ÙŠÙ† Ù…Ø®ØªÙ„ÙØ§Ù† (Ø¥Ø°Ø§ ØªØ³Ø§ÙˆÙŠØ§ØŒ Ù†Ø¹Ø¯Ù„ Ø§Ù„Ø«Ø§Ù†ÙŠ)
                if (CONFIG.FREQ_0 === CONFIG.FREQ_1) {
                    CONFIG.FREQ_1 = CONFIG.FREQ_0 + 100;
                    if (CONFIG.FREQ_1 > 22000) CONFIG.FREQ_1 = CONFIG.FREQ_0 - 100;
                    freq1Slider.value = CONFIG.FREQ_1;
                }
                CONFIG.BIT_DURATION = parseInt(bitDurationSlider.value, 10) / 1000;
                CONFIG.THRESHOLD = parseFloat(thresholdSlider.value);
                CONFIG.TOLERANCE = parseInt(toleranceSlider.value, 10);

                freq0Value.textContent = CONFIG.FREQ_0;
                freq1Value.textContent = CONFIG.FREQ_1;
                bitDurationValue.textContent = bitDurationSlider.value + ' ms';
                thresholdValue.textContent = CONFIG.THRESHOLD.toFixed(3);
                toleranceValue.textContent = CONFIG.TOLERANCE;
                freqLabels.innerHTML = `<span>F0: ${CONFIG.FREQ_0} Hz</span> <span>F1: ${CONFIG.FREQ_1} Hz</span>`;

                try {
                    localStorage.setItem('waveConfig', JSON.stringify(CONFIG));
                } catch (e) {}
            }

            freq0Slider.addEventListener('input', updateConfigFromSliders);
            freq1Slider.addEventListener('input', updateConfigFromSliders);
            bitDurationSlider.addEventListener('input', updateConfigFromSliders);
            thresholdSlider.addEventListener('input', updateConfigFromSliders);
            toleranceSlider.addEventListener('input', updateConfigFromSliders);

            toggleAdvancedBtn.addEventListener('click', () => {
                if (advancedPanel.style.display === 'none') {
                    advancedPanel.style.display = 'block';
                    toggleAdvancedBtn.textContent = 'ğŸ”½ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…';
                } else {
                    advancedPanel.style.display = 'none';
                    toggleAdvancedBtn.textContent = 'âš™ï¸ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…';
                }
            });

            // Ù…Ø¨Ø¯Ù„ Ø§Ù„ÙˆØ¶Ø¹
            modeUltrasonic.addEventListener('click', () => {
                modeUltrasonic.classList.add('active');
                modeAudible.classList.remove('active');
                freq0Slider.value = 19000;
                freq1Slider.value = 20000;
                updateConfigFromSliders();
            });
            modeAudible.addEventListener('click', () => {
                modeAudible.classList.add('active');
                modeUltrasonic.classList.remove('active');
                freq0Slider.value = 500;
                freq1Slider.value = 1000;
                updateConfigFromSliders();
            });

            let muteEnabled = CONFIG.MUTE_WHEN_SENDING;
            function updateMuteButton() {
                muteToggleBtn.textContent = muteEnabled ? 'ğŸ”‡ ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (Ù…ÙØ¹Ù„)' : 'ğŸ”Š ÙƒØªÙ… Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ (ØºÙŠØ± Ù…ÙØ¹Ù„)';
            }
            muteToggleBtn.addEventListener('click', () => {
                muteEnabled = !muteEnabled;
                CONFIG.MUTE_WHEN_SENDING = muteEnabled;
                updateMuteButton();
                localStorage.setItem('waveConfig', JSON.stringify(CONFIG));
            });
            updateMuteButton();

            // ==================== Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© ====================
            let audioContext = null;
            let isListening = false;
            let isSending = false;
            let mediaStream = null;
            let mediaStreamSource = null;
            let analyserNode = null;
            let gainNode = null;
            let animationFrame = null;
            let goertzelInterval = null;
            
            // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            let sentCount = 0, receivedCount = 0, errorCount = 0;
            function updateStats() {
                sentCountEl.textContent = sentCount;
                receivedCountEl.textContent = receivedCount;
                errorCountEl.textContent = errorCount;
            }

            // Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„
            let rxState = {
                phase: 'IDLE',           // IDLE, PREAMBLE, LENGTH, DATA, CHECKSUM
                preambleBits: '',
                lengthBits: '',
                dataBits: '',
                checksumBits: '',
                expectedLength: 0,
                dataBytes: [],
                lastBitTime: 0,
                bitWindow: 0,
                bitsBuffer: ''            // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ØªØ§Øª Ø§Ù„Ø®Ø§Ù…
            };

            // Ù…ØªØºÙŠØ±Ø§Øª Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
            let currentTransferId = null;
            let totalChunks = 0;
            let receivedChunks = new Map();
            let transferType = '';
            let transferMetadata = {};

            // Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ø¯ÙŠÙ…
            let mediaRecorder = null;
            let audioChunks = [];
            let recordedBlob = null;
            let isRecording = false;

            // Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ù…ÙƒØªØ¨Ø©
            let recordingMediaRecorder = null;
            let recordingChunks = [];
            let isRecordingMode = false;

            // ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================
            function setStatus(text, ledClass) {
                statusText.innerText = text;
                led.className = 'led ' + ledClass;
            }

            function addMessage(text, type = 'received', isHtml = false) {
                const msg = document.createElement('div');
                msg.classList.add('message', type);
                if (isHtml) {
                    msg.innerHTML = text;
                } else {
                    msg.textContent = text;
                }
                messagesDiv.appendChild(msg);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }

            function updateWaveBars(energy) {
                const activeCount = Math.floor(energy * waveBars.length);
                waveBars.forEach((bar, i) => {
                    if (i < activeCount) {
                        bar.style.height = 30 + energy * 50 + 'px';
                        bar.classList.add('active');
                    } else {
                        bar.style.height = '20px';
                        bar.classList.remove('active');
                    }
                });
            }

            function updateDbLevel() {
                if (!analyserNode || !isListening) return;
                const dataArray = new Float32Array(analyserNode.frequencyBinCount);
                analyserNode.getFloatTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / dataArray.length);
                const db = 20 * Math.log10(rms + 1e-10);
                const normalized = Math.min(1, Math.max(0, (db + 100) / 60));
                dbFill.style.width = (normalized * 100) + '%';
                dbValue.textContent = db.toFixed(1) + ' dB';
            }

            async function initAudio() {
                if (audioContext && audioContext.state !== 'closed') return audioContext;
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: CONFIG.SAMPLE_RATE });
                    if (audioContext.state === 'suspended') await audioContext.resume();
                    return audioContext;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Audio Context:', err);
                    errorCount++;
                    updateStats();
                    throw err;
                }
            }

            // ==================== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Goertzel Ù…Ø­Ø³Ù‘Ù†Ø© ====================
            function goertzel(samples, targetFreq, sampleRate) {
                const N = samples.length;
                let coeff = 2 * Math.cos(2 * Math.PI * targetFreq / sampleRate);
                let sPrev = 0, sPrev2 = 0;
                // Ù†Ø§ÙØ°Ø© Ù‡Ø§Ù…ÙŠÙ†Øº
                for (let i = 0; i < N; i++) {
                    let windowVal = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1));
                    let sample = samples[i] * windowVal;
                    let s = sample + coeff * sPrev - sPrev2;
                    sPrev2 = sPrev;
                    sPrev = s;
                }
                return sPrev2 * sPrev2 + sPrev * sPrev - coeff * sPrev * sPrev2;
            }

            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨Øª ÙˆØ§Ø­Ø¯ Ù…Ù† Ø¹ÙŠÙ†Ø© (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Goertzel)
            function detectBitFromSamples(samples) {
                const energy0 = goertzel(samples, CONFIG.FREQ_0, CONFIG.SAMPLE_RATE);
                const energy1 = goertzel(samples, CONFIG.FREQ_1, CONFIG.SAMPLE_RATE);
                return (energy1 / (energy0 + 1e-10)) > CONFIG.THRESHOLD ? 1 : 0;
            }

            // ==================== Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± ====================
            function startListening() {
                if (isListening) return;
                initAudio().then(async (ctx) => {
                    try {
                        mediaStream = await navigator.mediaDevices.getUserMedia({ 
                            audio: { 
                                echoCancellation: false, 
                                noiseSuppression: false,
                                autoGainControl: false
                            } 
                        });
                        mediaStreamSource = ctx.createMediaStreamSource(mediaStream);
                        analyserNode = ctx.createAnalyser();
                        analyserNode.fftSize = CONFIG.FFT_SIZE;
                        analyserNode.smoothingTimeConstant = 0.2;
                        gainNode = ctx.createGain();
                        gainNode.gain.value = 1;
                        mediaStreamSource.connect(analyserNode);
                        analyserNode.connect(gainNode);
                        gainNode.connect(ctx.destination);
                        
                        isListening = true;
                        setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                        addMessage('ğŸ§ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹...', 'system');
                        
                        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„
                        resetRxState();
                        
                        // Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª ÙˆØ§Ù„Ù…ÙˆØ¬Ø§Øª (Ù…Ø±Ø¦ÙŠ ÙÙ‚Ø·)
                        function updateVisuals() {
                            if (!isListening) return;
                            updateDbLevel();
                            // Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ù„Ù…ÙˆØ¬Ø© (Ù„Ù„Ø¥ÙŠØ­Ø§Ø¡ Ø¨Ø§Ù„Ø­ÙŠØ§Ø©)
                            updateWaveBars(0.3 + Math.random() * 0.2);
                            animationFrame = requestAnimationFrame(updateVisuals);
                        }
                        animationFrame = requestAnimationFrame(updateVisuals);
                        
                        // Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù Ø§Ù„Ø¯ÙˆØ±ÙŠ Ù„Ù„Ø¨ØªØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… setInterval Ø¨Ø¯Ù‚Ø©
                        const samplesPerBit = CONFIG.SAMPLES_PER_BIT;
                        const bufferSize = 2048; // Ø­Ø¬Ù… Ù…Ù†Ø§Ø³Ø¨
                        const inputBuffer = new Float32Array(bufferSize);
                        
                        goertzelInterval = setInterval(() => {
                            if (!isListening || !analyserNode) return;
                            
                            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹ÙŠÙ†Ø§Øª Ø­Ø¯ÙŠØ«Ø©
                            analyserNode.getFloatTimeDomainData(inputBuffer);
                            
                            // Ù†Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¹ÙŠÙ†Ø§Øª Ø¨Ù…Ø¹Ø¯Ù„ 48 ÙƒÙŠÙ„ÙˆÙ‡ÙŠØ±ØªØ²ØŒ Ù†Ø£Ø®Ø° Ø¢Ø®Ø± samplesPerBit Ø¹ÙŠÙ†Ø©
                            // Ø¥Ø°Ø§ ÙƒØ§Ù† bufferSize < samplesPerBit Ù†Ø£Ø®Ø° ÙƒÙ„ Ø§Ù„Ù…ØªØ§Ø­
                            const start = Math.max(0, inputBuffer.length - samplesPerBit);
                            const samples = inputBuffer.slice(start);
                            
                            if (samples.length < samplesPerBit * 0.8) return; // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹ÙŠÙ†Ø§Øª ÙƒØ§ÙÙŠØ©
                            
                            const bit = detectBitFromSamples(samples);
                            processBit(bit);
                        }, CONFIG.BIT_DURATION * 1000 * 0.9); // Ø£Ù‚Ù„ Ø¨Ù‚Ù„ÙŠÙ„ Ù…Ù† Ù…Ø¯Ø© Ø§Ù„Ø¨Øª Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªØºØ·ÙŠØ©
                        
                    } catch (err) {
                        console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹:', err);
                        errorCount++;
                        updateStats();
                        alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†:\n' + err.message);
                        setStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', '');
                        isListening = false;
                    }
                });
            }

            function stopListening() {
                if (!isListening) return;
                isListening = false;
                setStatus('Ù…ØªÙˆÙ‚Ù', '');
                if (animationFrame) cancelAnimationFrame(animationFrame);
                if (goertzelInterval) clearInterval(goertzelInterval);
                if (mediaStreamSource) {
                    mediaStreamSource.disconnect();
                    mediaStream.getTracks().forEach(t => t.stop());
                }
                addMessage('â¹ï¸ ØªÙˆÙ‚Ù Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'system');
                resetRxState();
            }

            function resetRxState() {
                rxState = {
                    phase: 'IDLE',
                    preambleBits: '',
                    lengthBits: '',
                    dataBits: '',
                    checksumBits: '',
                    expectedLength: 0,
                    dataBytes: [],
                    lastBitTime: 0,
                    bitWindow: 0,
                    bitsBuffer: ''
                };
            }

            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Øª Ø¬Ø¯ÙŠØ¯
            function processBit(bit) {
                const now = Date.now();
                // ØªØ¬Ø§ÙˆØ² Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† Ø§Ù„Ø¨ØªØ§Øª Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹ (ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±)
                if (now - rxState.lastBitTime < CONFIG.BIT_DURATION * 1000 * 0.5) return;
                rxState.lastBitTime = now;
                
                rxState.bitsBuffer += bit;
                
                // Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª
                if (rxState.phase === 'IDLE') {
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† preamble
                    rxState.preambleBits += bit;
                    if (rxState.preambleBits.length > 80) { // Ø·ÙˆÙ„ preamble Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ = 5*8 = 40ØŒ Ù†ØªØ±Ùƒ Ù‡Ø§Ù…Ø´
                        rxState.preambleBits = rxState.preambleBits.slice(-40); // Ù†Ø­ØªÙØ¸ Ø¨Ø¢Ø®Ø± 40 Ø¨Øª
                    }
                    
                    const preambleBinary = CONFIG.PREAMBLE.map(b => b.toString(2).padStart(8, '0')).join('');
                    if (rxState.preambleBits.length >= preambleBinary.length) {
                        const candidate = rxState.preambleBits.slice(-preambleBinary.length);
                        const distance = hammingDistance(candidate, preambleBinary);
                        if (distance <= CONFIG.TOLERANCE) {
                            // ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ preamble
                            rxState.phase = 'LENGTH';
                            rxState.preambleBits = ''; // ØªÙ†Ø¸ÙŠÙ
                            rxState.lengthBits = '';
                            addMessage('ğŸ“¡ ØªÙ… ÙƒØ´Ù Ø§Ù„Ù€ Preamble', 'system');
                        }
                    }
                }
                else if (rxState.phase === 'LENGTH') {
                    rxState.lengthBits += bit;
                    if (rxState.lengthBits.length === 8) {
                        rxState.expectedLength = parseInt(rxState.lengthBits, 2);
                        rxState.phase = 'DATA';
                        rxState.dataBits = '';
                        rxState.dataBytes = [];
                        addMessage(`ğŸ“¦ Ø­Ø¬Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${rxState.expectedLength} Ø¨Ø§ÙŠØª`, 'system');
                    }
                }
                else if (rxState.phase === 'DATA') {
                    rxState.dataBits += bit;
                    // Ø¹Ù†Ø¯Ù…Ø§ Ù†Ø¬Ù…Ø¹ 8 Ø¨ØªØ§Øª Ù†Ø­ÙˆÙ„ Ø¥Ù„Ù‰ Ø¨Ø§ÙŠØª
                    while (rxState.dataBits.length >= 8) {
                        const byteBits = rxState.dataBits.substring(0, 8);
                        rxState.dataBits = rxState.dataBits.substring(8);
                        const byte = parseInt(byteBits, 2);
                        rxState.dataBytes.push(byte);
                    }
                    // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù…Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
                    if (rxState.dataBytes.length >= rxState.expectedLength * CONFIG.REPETITION) {
                        rxState.phase = 'CHECKSUM';
                        rxState.checksumBits = '';
                    }
                }
                else if (rxState.phase === 'CHECKSUM') {
                    rxState.checksumBits += bit;
                    if (rxState.checksumBits.length === 8) {
                        const receivedChecksum = parseInt(rxState.checksumBits, 2);
                        
                        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… majority vote
                        const finalBytes = [];
                        for (let i = 0; i < rxState.expectedLength; i++) {
                            const repeats = [];
                            for (let r = 0; r < CONFIG.REPETITION; r++) {
                                repeats.push(rxState.dataBytes[i * CONFIG.REPETITION + r]);
                            }
                            finalBytes.push(majorityVote(repeats));
                        }
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† checksum
                        let calcChecksum = rxState.expectedLength;
                        for (let b of finalBytes) calcChecksum ^= b;
                        
                        if (receivedChecksum === calcChecksum) {
                            // Ù†Ø¬Ø§Ø­
                            processReceivedData(finalBytes);
                        } else {
                            errorCount++;
                            updateStats();
                            addMessage('âŒ Ø®Ø·Ø£ Checksum', 'system');
                        }
                        
                        // Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø­Ø§Ù„Ø© IDLE
                        rxState.phase = 'IDLE';
                        rxState.preambleBits = '';
                    }
                }
            }

            // Ù…Ø³Ø§ÙØ© Ù‡Ø§Ù…ÙŠÙ†Øº
            function hammingDistance(str1, str2) {
                if (str1.length !== str2.length) return Infinity;
                let dist = 0;
                for (let i = 0; i < str1.length; i++) if (str1[i] !== str2[i]) dist++;
                return dist;
            }

            // Ø§Ù„ØªØµÙˆÙŠØª Ø¨Ø§Ù„Ø£ØºÙ„Ø¨ÙŠØ©
            function majorityVote(arr) {
                const counts = {};
                for (let val of arr) counts[val] = (counts[val] || 0) + 1;
                return parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));
            }

            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø© (Ù†Øµ Ø£Ùˆ Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØµÙÙŠØ©)
            function processReceivedData(bytes) {
                try {
                    const text = new TextDecoder().decode(new Uint8Array(bytes));
                    
                    if (text.startsWith('META:')) {
                        const meta = JSON.parse(text.substring(5));
                        transferType = meta.type;
                        transferMetadata = meta;
                        receivedChunks.clear();
                        addMessage(`ğŸ“¥ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù…Ù„Ù: ${meta.name} (${meta.chunks} Ø£Ø¬Ø²Ø§Ø¡)`, 'system');
                        progressContainer.style.display = 'block';
                        progressFill.style.width = '0%';
                    } 
                    else if (text.startsWith('CHUNK:')) {
                        const parts = text.split(':');
                        const id = parts[1];
                        const index = parseInt(parts[2]);
                        const data = parts.slice(3).join(':');
                        receivedChunks.set(index, data);
                        const progress = (receivedChunks.size / transferMetadata.chunks) * 100;
                        progressFill.style.width = progress + '%';
                        
                        if (receivedChunks.size === transferMetadata.chunks) {
                            assembleFile();
                        }
                    } 
                    else {
                        // Ø±Ø³Ø§Ù„Ø© Ù†ØµÙŠØ© Ø¹Ø§Ø¯ÙŠØ©
                        if (text.trim() !== '') {
                            addMessage(text, 'received');
                            receivedCount++;
                            updateStats();
                        }
                    }
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±', 'system');
                }
            }

            function assembleFile() {
                try {
                    let fullBase64 = '';
                    for (let i = 0; i < transferMetadata.chunks; i++) {
                        fullBase64 += receivedChunks.get(i);
                    }
                    const binaryString = atob(fullBase64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                    const blob = new Blob([bytes], { type: transferMetadata.mime });
                    const url = URL.createObjectURL(blob);
                    
                    const container = document.createElement('div');
                    container.classList.add('message', 'received');
                    
                    if (transferMetadata.type === 'image' || transferMetadata.type === 'ØµÙˆØ±Ø©') {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.maxWidth = '200px';
                        img.style.borderRadius = '12px';
                        container.appendChild(img);
                    } else if (transferMetadata.type === 'video' || transferMetadata.type === 'ÙÙŠØ¯ÙŠÙˆ') {
                        const video = document.createElement('video');
                        video.src = url;
                        video.controls = true;
                        video.style.maxWidth = '100%';
                        container.appendChild(video);
                    } else if (transferMetadata.type === 'audio') {
                        const audio = document.createElement('audio');
                        audio.src = url;
                        audio.controls = true;
                        audio.style.width = '100%';
                        container.appendChild(audio);
                    }
                    
                    messagesDiv.appendChild(container);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    receivedCount++;
                    updateStats();
                    addMessage(`âœ… ØªÙ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ ${transferMetadata.name}`, 'system');
                    progressContainer.style.display = 'none';
                    currentTransferId = null;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„Ù:', err);
                    errorCount++;
                    updateStats();
                }
            }

            // ==================== Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ====================
            function encodeBytesToFrame(bytes) {
                let frame = [...CONFIG.PREAMBLE];
                frame.push(bytes.length);
                for (let b of bytes) {
                    for (let r = 0; r < CONFIG.REPETITION; r++) frame.push(b);
                }
                let checksum = bytes.length;
                for (let b of bytes) checksum ^= b;
                frame.push(checksum);
                return frame;
            }

            function createWaveform(bytes) {
                const samplesPerBit = CONFIG.SAMPLES_PER_BIT;
                const totalBits = bytes.length * 8;
                const totalSamples = totalBits * samplesPerBit;
                const audioBuffer = audioContext.createBuffer(1, totalSamples, CONFIG.SAMPLE_RATE);
                const channel = audioBuffer.getChannelData(0);
                
                const hanning = (i, len) => 0.5 * (1 - Math.cos(2 * Math.PI * i / (len - 1)));
                
                let idx = 0;
                for (let byte of bytes) {
                    for (let i = 7; i >= 0; i--) {
                        const bit = (byte >> i) & 1;
                        const freq = bit ? CONFIG.FREQ_1 : CONFIG.FREQ_0;
                        const omega = 2 * Math.PI * freq / CONFIG.SAMPLE_RATE;
                        // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ
                        currentBitDisplay.textContent = `ğŸ”Š Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: ${bit} (ØªØ±Ø¯Ø¯ ${freq} Hz)`;
                        for (let s = 0; s < samplesPerBit; s++) {
                            // ØªØ·Ø¨ÙŠÙ‚ Ù†Ø§ÙØ°Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù†Ù‚Ø±Ø§Øª
                            let windowFactor = 1;
                            if (s < samplesPerBit * 0.1) windowFactor = hanning(s, samplesPerBit * 0.1);
                            else if (s > samplesPerBit * 0.9) windowFactor = hanning(samplesPerBit - s - 1, samplesPerBit * 0.1);
                            channel[idx++] = Math.sin(omega * s) * windowFactor * 0.9;
                        }
                    }
                }
                return audioBuffer;
            }

            async function sendBytes(bytes, desc = 'Ø¨ÙŠØ§Ù†Ø§Øª') {
                if (isSending) {
                    addMessage('âš ï¸ Ù‡Ù†Ø§Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¬Ø§Ø±ÙŠØŒ Ø§Ù†ØªØ¸Ø±', 'system');
                    return;
                }
                isSending = true;
                setStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...', 'sending');
                
                if (muteEnabled && gainNode) {
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                }
                
                try {
                    const ctx = await initAudio();
                    const buffer = createWaveform(bytes);
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    source.start();
                    
                    const durationMs = (buffer.length / CONFIG.SAMPLE_RATE) * 1000;
                    const startTime = Date.now();
                    
                    const interval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const prog = Math.min(1, elapsed / durationMs);
                        updateWaveBars(prog);
                        if (prog >= 1) {
                            clearInterval(interval);
                            updateWaveBars(0);
                            isSending = false;
                            setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                            currentBitDisplay.textContent = 'â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -';
                            if (muteEnabled && gainNode) {
                                gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                            }
                        }
                    }, 50);
                    
                    source.onended = () => {
                        clearInterval(interval);
                        updateWaveBars(0);
                        isSending = false;
                        setStatus('ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'listening');
                        currentBitDisplay.textContent = 'â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -';
                        if (muteEnabled && gainNode) {
                            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                        }
                    };
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:', err);
                    isSending = false;
                    errorCount++;
                    updateStats();
                    setStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', '');
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ' + err.message, 'system');
                    currentBitDisplay.textContent = 'â³ Ø§Ù„Ø¨Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: -';
                    if (muteEnabled && gainNode) {
                        gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    }
                }
            }

            async function sendText(text) {
                try {
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(text);
                    const frame = encodeBytesToFrame(bytes);
                    await sendBytes(frame, 'Ù†Øµ');
                    addMessage(text, 'sent');
                    sentCount++;
                    updateStats();
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 'system');
                }
            }

            // Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù (ØµÙˆØ±Ø©ØŒ ÙÙŠØ¯ÙŠÙˆØŒ ØµÙˆØª)
            async function sendFile(file, type) {
                try {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const base64 = e.target.result.split(',')[1];
                            const chunkSize = CONFIG.CHUNK_SIZE;
                            const totalChunks = Math.ceil(base64.length / chunkSize);
                            const transferId = Date.now().toString(36) + Math.random().toString(36).substring(2, 8);
                            
                            addMessage(`ğŸ–¼ï¸ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ ${type}: ${file.name} (${totalChunks} Ø¬Ø²Ø¡)`, 'system');
                            
                            const meta = JSON.stringify({
                                type: type,
                                id: transferId,
                                name: file.name,
                                mime: file.type,
                                size: base64.length,
                                chunks: totalChunks
                            });
                            const metaBytes = new TextEncoder().encode('META:' + meta);
                            await sendBytes(encodeBytesToFrame(metaBytes), 'metadata');
                            
                            progressContainer.style.display = 'block';
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = base64.substr(i * chunkSize, chunkSize);
                                const chunkData = `CHUNK:${transferId}:${i}:${chunk}`;
                                const chunkBytes = new TextEncoder().encode(chunkData);
                                await sendBytes(encodeBytesToFrame(chunkBytes), `Ø¬Ø²Ø¡ ${i+1}/${totalChunks}`);
                                progressFill.style.width = ((i + 1) / totalChunks * 100) + '%';
                                // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ù„ØªØ¬Ù†Ø¨ Ø§Ù†Ø³Ø¯Ø§Ø¯ Ø§Ù„Ù…ØªØµÙØ­
                                await new Promise(r => setTimeout(r, 200));
                            }
                            progressContainer.style.display = 'none';
                            addMessage(`âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${type}`, 'system');
                            sentCount++;
                            updateStats();
                        } catch (err) {
                            console.error('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù:', err);
                            errorCount++;
                            updateStats();
                            addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù', 'system');
                        }
                    };
                    reader.readAsDataURL(file);
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù:', err);
                    errorCount++;
                    updateStats();
                }
            }

            // ==================== Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ù‚Ø¯ÙŠÙ… ====================
            async function startRecording() {
                if (isRecording) return;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendAudioBtn.disabled = false;
                        addMessage(`ğŸ¤ ØªÙ… ØªØ³Ø¬ÙŠÙ„ ${(recordedBlob.size / 1024).toFixed(1)} ÙƒÙŠÙ„ÙˆØ¨Ø§ÙŠØª`, 'system');
                        stream.getTracks().forEach(t => t.stop());
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = 'â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„';
                    recordBtn.style.background = '#dc2626';
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†:', err);
                    errorCount++;
                    updateStats();
                    alert('âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†: ' + err.message);
                }
            }

            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordBtn.textContent = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„';
                    recordBtn.style.background = '';
                }
            }

            async function sendAudio() {
                if (!recordedBlob) return;
                await sendFile(recordedBlob, 'audio');
                recordedBlob = null;
                sendAudioBtn.disabled = true;
            }

            // ==================== Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ù…ÙƒØªØ¨Ø© ====================
            async function startRecordingMode() {
                if (isRecordingMode) return;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    recordingMediaRecorder = new MediaRecorder(stream);
                    recordingChunks = [];
                    recordingMediaRecorder.ondataavailable = (e) => recordingChunks.push(e.data);
                    recordingMediaRecorder.onstop = async () => {
                        const blob = new Blob(recordingChunks, { type: 'audio/webm' });
                        const name = prompt('Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ø§Ù‹ Ù„Ù‡Ø°Ø§ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)', `ØªØ³Ø¬ÙŠÙ„ ${new Date().toLocaleString()}`);
                        await saveRecordingToDB(blob, name || `ØªØ³Ø¬ÙŠÙ„ ${new Date().toLocaleString()}`);
                        addMessage(`ğŸ’¾ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø§Ù„Ù…ÙƒØªØ¨Ø©`, 'system');
                        stream.getTracks().forEach(t => t.stop());
                        isRecordingMode = false;
                        setStatus('Ø®Ø§Ù…Ù„', '');
                        startRecordBtn.disabled = false;
                        stopRecordBtn.disabled = true;
                    };
                    recordingMediaRecorder.start();
                    isRecordingMode = true;
                    setStatus('ØªØ³Ø¬ÙŠÙ„...', 'recording');
                    startRecordBtn.disabled = true;
                    stopRecordBtn.disabled = false;
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:', err);
                    errorCount++;
                    updateStats();
                    alert('âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†: ' + err.message);
                }
            }

            function stopRecordingMode() {
                if (recordingMediaRecorder && isRecordingMode) {
                    recordingMediaRecorder.stop();
                }
            }

            // ==================== IndexedDB ====================
            const DB_NAME = 'AudioRecordingsDB';
            const STORE_NAME = 'recordings';

            function openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        }
                    };
                });
            }

            async function saveRecordingToDB(blob, name) {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const record = {
                        name: name,
                        blob: blob,
                        type: blob.type,
                        size: blob.size,
                        timestamp: Date.now()
                    };
                    const request = store.add(record);
                    request.onsuccess = () => {
                        resolve(request.result);
                        loadLibrary();
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async function getAllRecordings() {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async function deleteRecording(id) {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(id);
                    request.onsuccess = () => {
                        resolve();
                        loadLibrary();
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async function loadLibrary() {
                try {
                    const recordings = await getAllRecordings();
                    libraryList.innerHTML = '';
                    if (recordings.length === 0) {
                        libraryList.innerHTML = '<div class="message system">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ³Ø¬ÙŠÙ„Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©</div>';
                        return;
                    }
                    recordings.sort((a, b) => b.timestamp - a.timestamp);
                    recordings.forEach(rec => {
                        const item = document.createElement('div');
                        item.className = 'library-item';
                        item.innerHTML = `
                            <span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${rec.name}</span>
                            <div>
                                <button onclick="window.decodeRecording(${rec.id})">ğŸ”“ ÙÙƒ</button>
                                <button class="delete" onclick="window.deleteRecording(${rec.id})">ğŸ—‘ï¸</button>
                            </div>
                        `;
                        libraryList.appendChild(item);
                    });
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©:', err);
                }
            }

            window.decodeRecording = async (id) => {
                try {
                    const db = await openDB();
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(id);
                    request.onsuccess = () => {
                        const record = request.result;
                        if (record && record.blob) {
                            const file = new File([record.blob], record.name, { type: record.blob.type });
                            decodeAudioFromFile(file);
                        }
                    };
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:', err);
                }
            };

            window.deleteRecording = async (id) => {
                if (confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ØŸ')) {
                    await deleteRecording(id);
                }
            };

            loadLibrary();
            refreshLibraryBtn.addEventListener('click', loadLibrary);

            // ==================== ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØªÙŠØ© ====================
            async function decodeAudioFromFile(file) {
                try {
                    const ctx = await initAudio();
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                    const channelData = audioBuffer.getChannelData(0);
                    addMessage(`ğŸ” Ø¨Ø¯Ø¡ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ù„Ù: ${file.name}`, 'system');
                    
                    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ØªØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Goertzel Ù„ÙƒÙ„ Ù†Ø§ÙØ°Ø©
                    const samplesPerBit = CONFIG.SAMPLES_PER_BIT;
                    const numBits = Math.floor(channelData.length / samplesPerBit);
                    let bits = '';
                    for (let i = 0; i < numBits; i++) {
                        const start = i * samplesPerBit;
                        const end = start + samplesPerBit;
                        const windowSamples = channelData.slice(start, end);
                        const bit = detectBitFromSamples(windowSamples);
                        bits += bit;
                    }
                    
                    // Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
                    const decodedText = extractTextFromBits(bits);
                    if (decodedText) {
                        // Ø¥Ø¸Ù‡Ø§Ø± ÙƒØ±Ø³Ø§Ù„Ø© ÙˆØ§Ø±Ø¯Ø©
                        processReceivedData(new TextEncoder().encode(decodedText));
                        receivedCount++;
                        updateStats();
                    } else {
                        addMessage('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ù…Ù„Ù', 'system');
                    }
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ù„Ù:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ù„Ù: ' + err.message, 'system');
                }
            }

            // Ù†Ø³Ø®Ø© Ù…Ø¨Ø³Ø·Ø© Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„Ø¨ØªØ§Øª (Ù…Ù…Ø§Ø«Ù„Ø© Ù„Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø©)
            function extractTextFromBits(bits) {
                // ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ù…Ù†Ø·Ø¬ Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ù„ÙƒÙ† Ù‡Ù†Ø§ Ù†Ø¨Ø³Ø·: Ù†Ø¨Ø­Ø« Ø¹Ù† preamble ÙˆÙ†ÙÙƒ Ø§Ù„Ø·ÙˆÙ„ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                const preambleBinary = CONFIG.PREAMBLE.map(b => b.toString(2).padStart(8, '0')).join('');
                let idx = bits.indexOf(preambleBinary);
                if (idx === -1) return null;
                bits = bits.substring(idx + preambleBinary.length);
                if (bits.length < 8) return null;
                const lengthBits = bits.substring(0, 8);
                const expectedLength = parseInt(lengthBits, 2);
                bits = bits.substring(8);
                const totalDataBits = expectedLength * CONFIG.REPETITION * 8;
                if (bits.length < totalDataBits) return null;
                const dataBits = bits.substring(0, totalDataBits);
                bits = bits.substring(totalDataBits);
                if (bits.length < 8) return null;
                const checksumBits = bits.substring(0, 8);
                const receivedChecksum = parseInt(checksumBits, 2);
                
                // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù…ØªÙƒØ±Ø±Ø©
                let dataBytes = [];
                for (let i = 0; i < totalDataBits; i += 8) {
                    const byteBits = dataBits.substring(i, i + 8);
                    dataBytes.push(parseInt(byteBits, 2));
                }
                
                // Ø§Ù„ØªØµÙˆÙŠØª
                const finalBytes = [];
                for (let i = 0; i < expectedLength; i++) {
                    const repeats = [];
                    for (let r = 0; r < CONFIG.REPETITION; r++) {
                        repeats.push(dataBytes[i * CONFIG.REPETITION + r]);
                    }
                    finalBytes.push(majorityVote(repeats));
                }
                
                let calcChecksum = expectedLength;
                for (let b of finalBytes) calcChecksum ^= b;
                
                if (receivedChecksum !== calcChecksum) return null;
                
                return new TextDecoder().decode(new Uint8Array(finalBytes));
            }

            // ==================== Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø£Ø²Ø±Ø§Ø± ====================
            startBtn.addEventListener('click', startListening);
            stopBtn.addEventListener('click', stopListening);
            sendBtn.addEventListener('click', () => {
                const text = messageInput.value.trim();
                if (text) {
                    sendText(text);
                    messageInput.value = '';
                }
            });
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const text = messageInput.value.trim();
                    if (text) {
                        sendText(text);
                        messageInput.value = '';
                    }
                }
            });
            testBtn.addEventListener('click', () => {
                sendText('ğŸ¤ Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªØ¨Ø§Ø±: Ù…Ø±Ø­Ø¨Ø§Ù‹! Ù‡Ù„ ØªØ³Ù…Ø¹Ù†ÙŠØŸ');
            });
            clearBtn.addEventListener('click', () => {
                messagesDiv.innerHTML = '<div class="message system">âœ¨ ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„.</div>';
                sentCount = 0;
                receivedCount = 0;
                errorCount = 0;
                updateStats();
            });
            attachImageBtn.addEventListener('click', () => imageInput.click());
            attachVideoBtn.addEventListener('click', () => videoInput.click());
            recordBtn.addEventListener('click', () => isRecording ? stopRecording() : startRecording());
            sendAudioBtn.addEventListener('click', sendAudio);
            imageInput.addEventListener('change', (e) => {
                if (e.target.files[0]) sendFile(e.target.files[0], 'ØµÙˆØ±Ø©');
            });
            videoInput.addEventListener('change', (e) => {
                if (e.target.files[0]) sendFile(e.target.files[0], 'ÙÙŠØ¯ÙŠÙˆ');
            });
            
            // Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ±Ø¯Ø¯Ø§Øª
            testFreq0Btn.addEventListener('click', async () => {
                try {
                    const ctx = await initAudio();
                    const duration = 1;
                    const samples = duration * CONFIG.SAMPLE_RATE;
                    const buffer = ctx.createBuffer(1, samples, CONFIG.SAMPLE_RATE);
                    const channel = buffer.getChannelData(0);
                    const omega = 2 * Math.PI * CONFIG.FREQ_0 / CONFIG.SAMPLE_RATE;
                    for (let i = 0; i < samples; i++) {
                        channel[i] = Math.sin(omega * i) * 0.8;
                    }
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    source.start();
                    addMessage(`ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± ØªØ±Ø¯Ø¯ ${CONFIG.FREQ_0} Hz`, 'system');
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©', 'system');
                }
            });

            testFreq1Btn.addEventListener('click', async () => {
                try {
                    const ctx = await initAudio();
                    const duration = 1;
                    const samples = duration * CONFIG.SAMPLE_RATE;
                    const buffer = ctx.createBuffer(1, samples, CONFIG.SAMPLE_RATE);
                    const channel = buffer.getChannelData(0);
                    const omega = 2 * Math.PI * CONFIG.FREQ_1 / CONFIG.SAMPLE_RATE;
                    for (let i = 0; i < samples; i++) {
                        channel[i] = Math.sin(omega * i) * 0.8;
                    }
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);
                    source.start();
                    addMessage(`ğŸ”Š Ø§Ø®ØªØ¨Ø§Ø± ØªØ±Ø¯Ø¯ ${CONFIG.FREQ_1} Hz`, 'system');
                } catch (err) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©:', err);
                    errorCount++;
                    updateStats();
                    addMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†ØºÙ…Ø©', 'system');
                }
            });

            startRecordBtn.addEventListener('click', startRecordingMode);
            stopRecordBtn.addEventListener('click', stopRecordingMode);
            audioFileInput.addEventListener('change', (e) => {
                decodeFileBtn.disabled = !e.target.files[0];
            });
            decodeFileBtn.addEventListener('click', async () => {
                if (audioFileInput.files[0]) {
                    await decodeAudioFromFile(audioFileInput.files[0]);
                    audioFileInput.value = '';
                    decodeFileBtn.disabled = true;
                }
            });

            // ØªÙ‡ÙŠØ¦Ø© Ø£ÙˆÙ„ÙŠØ©
            updateConfigFromSliders();
            updateStats();
        })();
    </script>
</body>
</html>